========== FILE: AudioService.cs ==========
// Assets/Scripts/Core/Audio/AudioService.cs
using Core.EventBusSystem;
using Core.Settings;
using Core.SceneManagement;
using UnityEngine;
using UnityEngine.Audio;

namespace Core.Audio
{
    [DefaultExecutionOrder(-120)]
    public sealed class AudioService : MonoBehaviour
    {
        public static AudioService Instance { get; private set; }

        [Header("Mixer")]
        [SerializeField] private AudioMixer masterMixer;
        [SerializeField] private string musicParam = "MusicVolume";
        [SerializeField] private string sfxParam   = "SFXVolume";

        [Header("Volumes (dB)")]
        [SerializeField] private float onDb  = 0f;
        [SerializeField] private float offDb = -80f;

        // ❌ повністю видалено RuntimeInitializeOnLoadMethod + самостворення!

        private void Awake()
        {
            if (Instance != null && Instance != this) { Destroy(gameObject); return; }
            Instance = this;
            DontDestroyOnLoad(gameObject);

            // fallback: якщо міксер не підв’язаний у префабі — спробуємо дістати з Resources
            if (!masterMixer)
                masterMixer = Resources.Load<AudioMixer>("Audio/MasterMixer");

            if (!masterMixer)
                Debug.LogError("[AudioService] No AudioMixer assigned/found. Assign in prefab or put at Resources/Audio/MasterMixer.mixer");
        }

        private void OnEnable()
        {
            EventBus.Subscribe<SettingsLoaded>(OnSettingsLoaded);
            EventBus.Subscribe<SettingsChanged>(OnSettingsChanged);
            EventBus.Subscribe<SceneReady>(OnSceneReady);

            // одразу синхронізуємо стан (раптом пропустили ранні події)
            EventBus.Invoke(new SettingsSyncRequested());
        }

        private void OnDisable()
        {
            EventBus.Unsubscribe<SettingsLoaded>(OnSettingsLoaded);
            EventBus.Unsubscribe<SettingsChanged>(OnSettingsChanged);
            EventBus.Unsubscribe<SceneReady>(OnSceneReady);
        }

        private void OnSettingsLoaded(SettingsLoaded e)  => Apply(e.MusicOn, e.SfxOn);
        private void OnSettingsChanged(SettingsChanged e) => Apply(e.MusicOn, e.SfxOn);

        private void OnSceneReady(SceneReady _)
        {
            EventBus.Invoke(new SettingsSyncRequested());
        }

        private void Apply(bool musicOn, bool sfxOn)
        {
            if (!masterMixer)
            {
                Debug.LogWarning("[AudioService] No AudioMixer assigned.");
                return;
            }
            masterMixer.SetFloat(musicParam, musicOn ? onDb : offDb);
            masterMixer.SetFloat(sfxParam,   sfxOn   ? onDb : offDb);
        }
    }
}


========== FILE: EventBus.cs ==========
using System;
using System.Collections.Generic;

namespace Core.EventBusSystem
{
    public static class EventBus
    {
        private static readonly Dictionary<Type, List<Delegate>> _subscribers = new();

        public static void Subscribe<T>(Action<T> callback)
        {
            var type = typeof(T);
            if (!_subscribers.ContainsKey(type))
                _subscribers[type] = new List<Delegate>();

            _subscribers[type].Add(callback);
        }

        public static void Unsubscribe<T>(Action<T> callback)
        {
            var type = typeof(T);
            if (_subscribers.TryGetValue(type, out var list))
            {
                list.Remove(callback);
                if (list.Count == 0)
                    _subscribers.Remove(type);
            }
        }

        public static void Invoke<T>(T eventData)
        {
            var type = typeof(T);
            if (_subscribers.TryGetValue(type, out var list))
            {
                var snapshot = list.ToArray(); 
                for (int i = 0; i < snapshot.Length; i++)
                    (snapshot[i] as Action<T>)?.Invoke(eventData);
            }
        }

    }
}

========== FILE: IState.cs ==========
namespace Core.FSM
{
    public interface IState
    {
        void Enter();
        void Exit();
        void Update();
    }
}


========== FILE: StateMachine.cs ==========
namespace Core.FSM
{
    public sealed class StateMachine
    {
        private IState _current;
        public IState Current => _current;

        public void Change(IState next)
        {
            if (_current == next) return;
            _current?.Exit();
            _current = next;
            _current?.Enter();
        }

        public void Update() => _current?.Update();
    }
}

========== FILE: GameEvents.cs ==========
namespace Core.GamePlay
{
    public static class GameEvents
    {
        public readonly struct PauseRequested { }
        public readonly struct ResumeRequested { }

        public readonly struct RestartRequested { }
        public readonly struct NextLevelRequested { }
        public readonly struct GoToMenuRequested { }

        public readonly struct LevelCompleted { }
        public readonly struct LevelFailed { }
    }
}

========== FILE: GameManager.cs ==========
using System.Collections.Generic;
using Core.EventBusSystem;
using Core.GamePlay.Levels;
using Core.GamePlay.Symboll;
using Core.GamePlay.UI;
using Core.SceneManagement;
using UnityEngine;

namespace Core.GamePlay
{
    /// <summary>
    /// Логіка рівня:
    /// 1) Спавнить символи згідно з JSON.
    /// 2) Генерує послідовність (зараз: усі символи по порядку).
    /// 3) ФАЗА ПОКАЗУ: промінь літає по послідовності, символи підсвічуються.
    /// 4) ФАЗА ВВОДУ: гравець клікає по символах у тому ж порядку.
    ///    - якщо клік правильний -> рухаємось далі;
    ///    - якщо помилковий -> LevelFailed();
    ///    - якщо вся послідовність пройдена -> LevelComplete().
    /// </summary>
    public class GameManager : MonoBehaviour
    {
        [Header("Refs")]
        public SunBeamController beam;

        [Tooltip("Позиції, де можуть спавнитись символи (по порядку).")]
        public Transform[] spawnPoints;

        [Tooltip("Всі види символів (префаби).")]
        public SymbolNode[] symbolPrefabs;

        [Header("Levels config file (JSON)")]
        public TextAsset levelsJson;   // сюди підкидаємо згенерований levels.json

        LevelsFile _levelsFile;
        LevelData _currentLevel;

        [Header("Debug / Manual")]
        [Tooltip("Який індекс рівня брати з JSON (0-based) при запуску сцени напряму.")]
        public int currentLevelIndex = 0;

        [Header("UI")]
        [SerializeField] private GameplayHud gameplayHud;

        readonly List<SymbolNode> _spawnedSymbols = new List<SymbolNode>();

        // послідовність, яку показуємо і яку гравець має повторити
        int[] _sequence;
        int _inputIndex = 0;

        bool _isShowingSequence = false;
        bool _isInputPhase = false;
        bool _levelFinished = false;
        bool _isPaused = false;

        int _lastHighlightedIndex = -1;

        private void OnEnable()
        {
            EventBus.Subscribe<GameEvents.RestartRequested>(OnRestartRequested);
            EventBus.Subscribe<GameEvents.NextLevelRequested>(OnNextLevelRequested);
            EventBus.Subscribe<GameEvents.GoToMenuRequested>(OnGoToMenuRequested);
            EventBus.Subscribe<GameEvents.PauseRequested>(OnPauseRequested);
            EventBus.Subscribe<GameEvents.ResumeRequested>(OnResumeRequested);
        }

        private void OnDisable()
        {
            EventBus.Unsubscribe<GameEvents.RestartRequested>(OnRestartRequested);
            EventBus.Unsubscribe<GameEvents.NextLevelRequested>(OnNextLevelRequested);
            EventBus.Unsubscribe<GameEvents.GoToMenuRequested>(OnGoToMenuRequested);
            EventBus.Unsubscribe<GameEvents.PauseRequested>(OnPauseRequested);
            EventBus.Unsubscribe<GameEvents.ResumeRequested>(OnResumeRequested);
        }

        void Start()
        {
            if (!beam)
            {
                Debug.LogError("GameManager: beam not set!");
                enabled = false;
                return;
            }

            if (!levelsJson)
            {
                Debug.LogError("GameManager: levelsJson (TextAsset) is not assigned!");
                enabled = false;
                return;
            }

            // розпарсити JSON
            _levelsFile = JsonUtility.FromJson<LevelsFile>(levelsJson.text);
            if (_levelsFile == null || _levelsFile.levels == null || _levelsFile.levels.Length == 0)
            {
                Debug.LogError("GameManager: no levels in JSON!");
                enabled = false;
                return;
            }

            if (currentLevelIndex < 0 || currentLevelIndex >= _levelsFile.levels.Length)
                currentLevelIndex = 0;

            _currentLevel = _levelsFile.levels[currentLevelIndex];

            if (gameplayHud != null)
                gameplayHud.SetLevel(currentLevelIndex + 1);

            SetupLevel();
            StartShowSequence();
        }

        void SetupLevel()
        {
            // видалити старі символи, якщо були
            foreach (var s in _spawnedSymbols)
            {
                if (s != null)
                    Destroy(s.gameObject);
            }
            _spawnedSymbols.Clear();

            if (_currentLevel.symbolPrefabIndices == null || _currentLevel.symbolPrefabIndices.Length == 0)
            {
                Debug.LogError("Current level has no symbolPrefabIndices!");
                return;
            }

            int count = Mathf.Min(_currentLevel.symbolPrefabIndices.Length, spawnPoints.Length);
            Transform[] beamPoints = new Transform[count];

            for (int i = 0; i < count; i++)
            {
                int prefabIndex = _currentLevel.symbolPrefabIndices[i];

                if (prefabIndex < 0 || prefabIndex >= symbolPrefabs.Length)
                {
                    Debug.LogError($"Invalid prefab index {prefabIndex} in level {currentLevelIndex}");
                    continue;
                }

                SymbolNode prefab = symbolPrefabs[prefabIndex];
                Transform point = spawnPoints[i];

                SymbolNode instance = Instantiate(prefab, point.position, Quaternion.identity);
                instance.SetIdle();
                instance.SetHighlighted(false);

                _spawnedSymbols.Add(instance);
                beamPoints[i] = instance.transform;
            }

            _lastHighlightedIndex = -1;
            _levelFinished = false;
            _isShowingSequence = false;
            _isInputPhase = false;
            _isPaused = false;
            Time.timeScale = 1f;

            // послідовність поки що: усі символи по порядку
            _sequence = new int[_spawnedSymbols.Count];
            for (int i = 0; i < _sequence.Length; i++)
                _sequence[i] = i;
        }

        /// <summary>
        /// Запускаємо ФАЗУ ПОКАЗУ: промінь ходить по символах у порядку _sequence.
        /// </summary>
        void StartShowSequence()
        {
            if (_sequence == null || _sequence.Length == 0)
            {
                Debug.LogError("GameManager: sequence is empty, nothing to show.");
                return;
            }

            _isShowingSequence = true;
            _isInputPhase = false;
            _inputIndex = 0;
            _lastHighlightedIndex = -1;

            Transform[] seqPoints = new Transform[_sequence.Length];
            for (int i = 0; i < _sequence.Length; i++)
            {
                int idx = _sequence[i];
                seqPoints[i] = _spawnedSymbols[idx].transform;
            }

            // Використовуємо moveSpeed / stopDuration з LevelData як параметри показу
            beam.PlaySequence(
                seqPoints,
                _currentLevel.moveSpeed,
                _currentLevel.stopDuration,
                OnShowStep,
                OnShowFinished
            );
        }

        /// <summary>
        /// Викликається SunBeamController для кожного кроку показу.
        /// крок i відповідає _sequence[i].
        /// </summary>
        void OnShowStep(int stepIndex)
        {
            int symbolIndex = _sequence[stepIndex];

            // гасимо попередній highlight
            if (_lastHighlightedIndex >= 0 && _lastHighlightedIndex < _spawnedSymbols.Count)
                _spawnedSymbols[_lastHighlightedIndex].SetHighlighted(false);

            // підсвічуємо поточний
            if (symbolIndex >= 0 && symbolIndex < _spawnedSymbols.Count)
            {
                _spawnedSymbols[symbolIndex].SetHighlighted(true);
                _lastHighlightedIndex = symbolIndex;
            }
        }

        /// <summary>
        /// Викликається, коли показ усієї послідовності завершений.
        /// </summary>
        void OnShowFinished()
        {
            // гасимо останній highlight
            if (_lastHighlightedIndex >= 0 && _lastHighlightedIndex < _spawnedSymbols.Count)
                _spawnedSymbols[_lastHighlightedIndex].SetHighlighted(false);

            _lastHighlightedIndex = -1;

            _isShowingSequence = false;
            _isInputPhase = true;
            _inputIndex = 0;

            Debug.Log("GameManager: sequence show finished. Waiting for player input...");
        }

        void Update()
        {
            if (_levelFinished || _isPaused)
                return;

            if (!_isInputPhase)
                return;

            bool pressed = false;
            Vector3 screenPos = Vector3.zero;

#if UNITY_ANDROID || UNITY_IOS
            if (Input.touchCount > 0 && Input.GetTouch(0).phase == TouchPhase.Began)
            {
                pressed = true;
                screenPos = Input.GetTouch(0).position;
            }
            if (Input.GetMouseButtonDown(0))
            {
                pressed = true;
                screenPos = Input.mousePosition;
            }
#else 
            if (Input.GetMouseButtonDown(0))
            {
                pressed = true;
                screenPos = Input.mousePosition;
            }
#endif

            if (pressed)
            {
                HandleInputClick(screenPos);
            }
        }

        void HandleInputClick(Vector3 screenPos)
        {
            if (Camera.main == null)
            {
                Debug.LogError("GameManager: no main camera for raycast.");
                return;
            }

            Vector3 worldPos = Camera.main.ScreenToWorldPoint(screenPos);
            Vector2 pos2D = new Vector2(worldPos.x, worldPos.y);

            var hit = Physics2D.Raycast(pos2D, Vector2.zero);
            if (!hit.collider)
                return;

            var node = hit.collider.GetComponent<SymbolNode>();
            if (!node)
                return;

            int clickedIndex = _spawnedSymbols.IndexOf(node);
            if (clickedIndex < 0)
                return;

            OnSymbolClicked(clickedIndex);
        }

        void OnSymbolClicked(int clickedIndex)
        {
            if (!_isInputPhase || _levelFinished || _isPaused)
                return;

            if (_inputIndex < 0 || _inputIndex >= _sequence.Length)
                return;

            int expectedIndex = _sequence[_inputIndex];

            if (clickedIndex == expectedIndex)
            {
                // правильний клік
                _spawnedSymbols[clickedIndex].Activate();
                Debug.Log($"Correct click {clickedIndex} (step {_inputIndex + 1}/{_sequence.Length})");

                _inputIndex++;

                if (_inputIndex >= _sequence.Length)
                {
                    LevelComplete();
                }
            }
            else
            {
                Debug.Log($"Wrong click! expected={expectedIndex}, got={clickedIndex}");
                LevelFailed();
            }
        }

        void LevelComplete()
        {
            _levelFinished = true;
            _isInputPhase = false;

            Debug.Log($"LEVEL COMPLETE! Level index = {currentLevelIndex}");
            EventBus.Invoke(new GameEvents.LevelCompleted());
        }

        void LevelFailed()
        {
            _levelFinished = true;
            _isInputPhase = false;

            Debug.Log($"LEVEL FAILED! Level index = {currentLevelIndex}");
            EventBus.Invoke(new GameEvents.LevelFailed());
        }

        // ---------- HANDLERS UI PODIY ----------

        void OnPauseRequested(GameEvents.PauseRequested _)
        {
            if (_levelFinished || _isPaused) return;
            _isPaused = true;
            Time.timeScale = 0f;
        }

        void OnResumeRequested(GameEvents.ResumeRequested _)
        {
            if (!_isPaused) return;
            _isPaused = false;
            Time.timeScale = 1f;
        }

        void OnRestartRequested(GameEvents.RestartRequested _)
        {
            _isPaused = false;
            Time.timeScale = 1f;
            // перезавантажуємо GameScene, рівень почнеться знову з тим самим currentLevelIndex
            SceneFlow.GoToGame(0.2f);
        }

        void OnNextLevelRequested(GameEvents.NextLevelRequested _)
        {
            _isPaused = false;
            Time.timeScale = 1f;

            int nextIndex = currentLevelIndex + 1;
            if (_levelsFile != null && _levelsFile.levels != null && nextIndex < _levelsFile.levels.Length)
            {
                currentLevelIndex = nextIndex;
                _currentLevel = _levelsFile.levels[currentLevelIndex];

                if (gameplayHud != null)
                    gameplayHud.SetLevel(currentLevelIndex + 1);

                SetupLevel();
                StartShowSequence();
            }
            else
            {
                // якщо наступного рівня нема — кидаємо в меню
                SceneFlow.GoToMenu(0.2f);
            }
        }

        void OnGoToMenuRequested(GameEvents.GoToMenuRequested _)
        {
            _isPaused = false;
            Time.timeScale = 1f;
            SceneFlow.GoToMenu(0.2f);
        }
    }
}


========== FILE: GameSession.cs ==========
// Assets/Scripts/Core/GamePlay/GameSession.cs
namespace Core.GamePlay
{
    public static class GameSession
    {
        /// <summary>
        /// Поточний індекс рівня із JSON (0-based).
        /// </summary>
        public static int CurrentLevelIndex { get; set; } = 0;

        /// <summary>
        /// Опціонально: айді з меню (якщо юзаєш рядкові LevelId).
        /// </summary>
        public static string CurrentLevelId { get; set; } = "0";
    }
}

========== FILE: SunBeamController.cs ==========
using System;
using System.Collections;
using UnityEngine;

namespace Core.GamePlay
{
    public class SunBeamController : MonoBehaviour
    {
        [Header("Beam Origin (стартова точка)")]
        [SerializeField] private Transform beamOrigin;

        [Header("Beam Prefab (movingPoint + TrailRenderer)")]
        [SerializeField] private GameObject beamPrefab;

        [Header("Settings")]
        [SerializeField] private float reachDistance = 0.05f;

        private GameObject _currentBeam;

        private Coroutine _routine;

        public void PlaySequence(
            Transform[] points,
            float moveSpeed,
            float stopDuration,
            Action<int> onStep,
            Action onFinished)
        {
            if (_routine != null)
                StopCoroutine(_routine);

            _routine = StartCoroutine(ShowRoutine(points, moveSpeed, stopDuration, onStep, onFinished));
        }

        private IEnumerator ShowRoutine(
            Transform[] points,
            float moveSpeed,
            float stopDuration,
            Action<int> onStep,
            Action onFinished)
        {
            for (int i = 0; i < points.Length; i++)
            {
                Vector3 target = points[i].position;

                // Створюємо новий промінь
                SpawnBeam();

                // Летимо
                yield return MoveBeamTo(target, moveSpeed);

                // повідомляємо GameManager про крок
                onStep?.Invoke(i);

                // чекаємо, поки символ підсвічений
                yield return new WaitForSeconds(stopDuration);

                // Видаляємо промінь
                ClearBeam();
            }

            ClearBeam();

            onFinished?.Invoke();
        }

        /// <summary>
        /// Створення нового променя
        /// </summary>
        private void SpawnBeam()
        {
            // Видаляємо попередній, якщо він був
            ClearBeam();

            _currentBeam = Instantiate(beamPrefab, beamOrigin.position, Quaternion.identity);
        }

        /// <summary>
        /// Рух beamPrefab → target
        /// </summary>
        private IEnumerator MoveBeamTo(Vector3 target, float speed)
        {
            Transform mover = _currentBeam.transform;

            // скидаємо трейл, якщо є
            var trail = mover.GetComponent<TrailRenderer>();
            if (trail) trail.Clear();

            while (Vector3.Distance(mover.position, target) > reachDistance)
            {
                mover.position = Vector3.MoveTowards(
                    mover.position,
                    target,
                    speed * Time.deltaTime
                );

                yield return null;
            }

            mover.position = target;
        }

        /// <summary>
        /// Видаляє поточний промінь
        /// </summary>
        private void ClearBeam()
        {
            if (_currentBeam != null)
            {
                Destroy(_currentBeam);
                _currentBeam = null;
            }
        }
    }
}


========== FILE: Bootstrap.cs ==========
// Assets/Scripts/Core/SceneManagement/Bootstrap.cs
using UnityEngine;
using Core.Audio; // ← додай

namespace Core.SceneManagement
{
    public static class Bootstrap
    {
        private const string LoadingScreenResPath = "UI/LoadingScreen";
        private const string AudioServiceResPath  = "Systems/AudioService"; // ← нове

        private const string MainMenuScene = "MainMenuScene";
        private const float  FirstShowDelay = 2.0f;

        //[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
        private static void Init()
        {
            // LoadingScreen
            if (LoadingScreen.Instance == null)
            {
                var prefab = Resources.Load<LoadingScreen>(LoadingScreenResPath);
                if (prefab != null) Object.Instantiate(prefab);
                else Debug.LogError("[Bootstrap] Missing Resources/UI/LoadingScreen.prefab with LoadingScreen component.");
            }

            // AudioService (без самостворення всередині сервісу)
            if (AudioService.Instance == null)
            {
                var audioPrefab = Resources.Load<AudioService>(AudioServiceResPath);
                if (audioPrefab != null) Object.Instantiate(audioPrefab);
                else Debug.LogError("[Bootstrap] Missing Resources/Systems/AudioService.prefab with AudioService component.");
            }

            // нормалізація часу (за бажанням)
            // Time.timeScale = 1f;

            LoadingScreen.Instance?.LoadScene(MainMenuScene, FirstShowDelay);
        }
    }
}

========== FILE: LoadingScreen.cs ==========
using System.Collections;
using Core.EventBusSystem;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.UI;
// ✨ додали
using Core.SceneManagement;    // ✨ додали (для SceneLoadingStarted/Loaded/Ready)

namespace Core.SceneManagement
{
    [DefaultExecutionOrder(-100)]
    public sealed class LoadingScreen : MonoBehaviour
    {
        public static LoadingScreen Instance { get; private set; }

        [Header("UI")]
        [SerializeField] private GameObject root;     // контейнер екрана завантаження
        [SerializeField] private Slider progressBar;  // індикатор прогресу (0..1)

        [Header("Config (Inspector)")]
        [SerializeField, Tooltip("Швидкість згладжування заповнення (візуально).")]
        private float smoothSpeed = 6f;

        // Значення за замовчуванням (якщо Bootstrap не передасть оверрайд)
        private const float DefaultFakeFinishTime = 1.0f;

        private Coroutine _routine;
        private bool _isLoading;
        private string _targetScene;

        private void Awake()
        {
            if (Instance != null && Instance != this) { Destroy(gameObject); return; }
            Instance = this;
            DontDestroyOnLoad(gameObject);

            if (root) root.SetActive(false);
            if (progressBar) progressBar.value = 0f;
        }

        /// <summary>
        /// Завантажує сцену з екраном завантаження.
        /// fakeDelayOverride — тривалість штучної фази 75% → 100% (сек), зазвичай задається Bootstrap-ом.
        /// </summary>
        public void LoadScene(string sceneName, float? fakeDelayOverride = null)
        {
            if (string.IsNullOrWhiteSpace(sceneName))
            {
                Debug.LogError("[LoadingScreen] Scene name is null or empty.");
                return;
            }

            // якщо намагаємось завантажити активну сцену — нічого не робимо
            if (SceneManager.GetActiveScene().name == sceneName)
            {
                Debug.LogWarning($"[LoadingScreen] Scene '{sceneName}' is already active.");
                root?.SetActive(false);
                return;
            }

            // перевірка на наявність у Build Settings
            if (!Application.CanStreamedLevelBeLoaded(sceneName))
            {
                Debug.LogError($"[LoadingScreen] Scene '{sceneName}' is not in Build Settings.");
                return;
            }

            // захист від повторних викликів одного й того ж лоаду
            if (_isLoading && _targetScene == sceneName)
                return;

            if (_routine != null) StopCoroutine(_routine);

            _isLoading = true;
            _targetScene = sceneName;

            root?.SetActive(true);
            if (progressBar) progressBar.value = 0f;

            float fakeDelay = fakeDelayOverride ?? DefaultFakeFinishTime;
            _routine = StartCoroutine(LoadSceneRoutine(sceneName, fakeDelay));
        }

        private IEnumerator LoadSceneRoutine(string sceneName, float fakeDelay)
        {
            // дати Canvas відмалюватися перед стартом важкого лоаду
            Canvas.ForceUpdateCanvases();
            yield return null;

            // ✨ нове: кинули подію "почали завантаження сцени"
            EventBus.Invoke(new SceneLoadingStarted(sceneName));

            var async = SceneManager.LoadSceneAsync(sceneName);
            async.allowSceneActivation = false;

            float shown = 0f;
            const float realPhaseMax = 0.75f; // до 75% — реальний прогрес
            const float unityCap     = 0.9f;  // Unity звітує 0.9 до активації

            // --- ФАЗА 1: реальний прогрес (0–75%) ---
            while (async.progress < unityCap)
            {
                float normalized = Mathf.Clamp01(async.progress / unityCap); // 0..1
                float target = normalized * realPhaseMax;                    // 0..0.75
                shown = Mathf.MoveTowards(shown, target, Time.unscaledDeltaTime * smoothSpeed);

                if (progressBar) progressBar.value = shown;
                yield return null;
            }

            // --- ФАЗА 2: штучна затримка 75–100% ---
            float timer = 0f;
            while (timer < fakeDelay)
            {
                timer += Time.unscaledDeltaTime;
                float t = Mathf.Clamp01(timer / fakeDelay);
                float target = Mathf.Lerp(realPhaseMax, 1f, t); // 0.75 → 1.0 за fakeDelay
                shown = Mathf.MoveTowards(shown, target, Time.unscaledDeltaTime * smoothSpeed);

                if (progressBar) progressBar.value = shown;
                yield return null;
            }

            // гарантувати 100% і дати один кадр завершення
            if (progressBar) progressBar.value = 1f;
            yield return null;

            // --- Активуємо сцену ---
            async.allowSceneActivation = true;
            while (!async.isDone) yield return null;

            // ✨ нове: повідомили, що сцена активована
            EventBus.Invoke(new SceneLoaded(sceneName));
            // ✨ нове: ще один кадр — даємо Awake/Start у новій сцені відпрацювати
            yield return null;
            // ✨ нове: тепер сцена гарантовано "готова" для UI/контролерів
            EventBus.Invoke(new SceneReady(sceneName));

            // короткий буфер, щоб уникнути "блимання" на дуже швидких сценах
            yield return new WaitForSecondsRealtime(0.2f);

            if (root) root.SetActive(false);
            _isLoading = false;
            _targetScene = null;
            _routine = null;
        }
    }
}


========== FILE: SceneEvents.cs ==========
namespace Core.SceneManagement
{
    public readonly struct SceneLoadingStarted { public readonly string Target; public SceneLoadingStarted(string t)=>Target=t; }
    public readonly struct SceneLoaded        { public readonly string Name;   public SceneLoaded(string n)=>Name=n; }
    public readonly struct SceneReady         { public readonly string Name;   public SceneReady(string n)=>Name=n; }
}

========== FILE: SceneFlow.cs ==========
namespace Core.SceneManagement
{
    public static class SceneFlow
    {
        public const string Menu = "MainMenuScene";
        public const string Game = "GameScene";

        public static void GoToMenu(float? fake = null) => LoadingScreen.Instance?.LoadScene(Menu, fake);
        public static void GoToGame(float? fake = null) => LoadingScreen.Instance?.LoadScene(Game, fake);
    }
}

========== FILE: SettingsEvents.cs ==========
namespace Core.Settings
{
    public readonly struct SettingsLoaded
    {
        public readonly bool MusicOn;
        public readonly bool SfxOn;
        public SettingsLoaded(bool musicOn, bool sfxOn) { MusicOn = musicOn; SfxOn = sfxOn; }
    }
    
    public readonly struct SettingsChanged
    {
        public readonly bool MusicOn;
        public readonly bool SfxOn;
        public SettingsChanged(bool musicOn, bool sfxOn) { MusicOn = musicOn; SfxOn = sfxOn; }
    }
    
    public readonly struct MusicToggleRequested { public readonly bool IsOn; public MusicToggleRequested(bool isOn) { IsOn = isOn; } }
    public readonly struct SfxToggleRequested   { public readonly bool IsOn; public SfxToggleRequested(bool isOn)   { IsOn = isOn; } }
    
    public readonly struct SettingsSyncRequested { }
}

========== FILE: SettingsService.cs ==========
// Assets/Scripts/Core/Settings/SettingsService.cs
using Core.EventBusSystem;
using UnityEngine;

namespace Core.Settings
{
    [DefaultExecutionOrder(-150)]
    public sealed class SettingsService : MonoBehaviour
    {
        public static SettingsService Instance { get; private set; }

        private const string KeyMusic = "settings.music_on";
        private const string KeySfx   = "settings.sfx_on";
        private const int    DefaultOn = 1;

        private bool _musicOn = true;
        private bool _sfxOn   = true;

        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
        private static void Bootstrap()
        {
            // забезпечуємо існування сервісу до завантаження будь-якої сцени
            if (Instance != null) return;
            var go = new GameObject("[SettingsService]");
            DontDestroyOnLoad(go);
            Instance = go.AddComponent<SettingsService>();
        }

        private void Awake()
        {
            if (Instance != null && Instance != this) { Destroy(gameObject); return; }
            Instance = this;
            DontDestroyOnLoad(gameObject);
            Load();
            // одразу розсилаємо стан, щоб інші підтягнулись
            EventBus.Invoke(new SettingsLoaded(_musicOn, _sfxOn));
            EventBus.Invoke(new SettingsChanged(_musicOn, _sfxOn));
        }

        private void OnEnable()
        {
            EventBus.Subscribe<MusicToggleRequested>(OnMusicToggleRequested);
            EventBus.Subscribe<SfxToggleRequested>(OnSfxToggleRequested);
            EventBus.Subscribe<SettingsSyncRequested>(OnSyncRequested);
        }

        private void OnDisable()
        {
            EventBus.Unsubscribe<MusicToggleRequested>(OnMusicToggleRequested);
            EventBus.Unsubscribe<SfxToggleRequested>(OnSfxToggleRequested);
            EventBus.Unsubscribe<SettingsSyncRequested>(OnSyncRequested);
        }

        private void OnMusicToggleRequested(MusicToggleRequested e)
        {
            if (_musicOn == e.IsOn) return;
            _musicOn = e.IsOn;
            Save();
            EventBus.Invoke(new SettingsChanged(_musicOn, _sfxOn));
        }

        private void OnSfxToggleRequested(SfxToggleRequested e)
        {
            if (_sfxOn == e.IsOn) return;
            _sfxOn = e.IsOn;
            Save();
            EventBus.Invoke(new SettingsChanged(_musicOn, _sfxOn));
        }

        private void OnSyncRequested(SettingsSyncRequested _)
        {
            EventBus.Invoke(new SettingsChanged(_musicOn, _sfxOn));
        }

        private void Load()
        {
            _musicOn = PlayerPrefs.GetInt(KeyMusic, DefaultOn) != 0;
            _sfxOn   = PlayerPrefs.GetInt(KeySfx,   DefaultOn) != 0;
        }

        private void Save()
        {
            PlayerPrefs.SetInt(KeyMusic, _musicOn ? 1 : 0);
            PlayerPrefs.SetInt(KeySfx,   _sfxOn   ? 1 : 0);
            PlayerPrefs.Save();
        }
    }
}


========== FILE: MainMenuController.cs ==========
using Core.EventBusSystem;
using UnityEngine;
using UnityEngine.SceneManagement;    // ✨ додали
using Core.SceneManagement;
using Menu.UI.Popups;

namespace Menu.UI
{
    public sealed class MainMenuController : MonoBehaviour
    {
        [Header("Popups")]
        [SerializeField] private MainMenuPopup mainMenuPopup;
        [SerializeField] private SettingsPopup settingsPopup;
        [SerializeField] private LevelSelectionPopup levelSelectionPopup;

        [Header("Config")]
        [SerializeField, Tooltip("Штучна доводка 75→100% при переході в гру")]
        private float startGameFakeFinish = 1.5f;

        private enum Panel { None, Main, Settings, Levels }
        private Panel _current = Panel.None;
        private bool _transitioning;

        private void Start()
        {
            // ✨ нове: якщо сцену меню запустили напряму з редактора (без LoadingScreen),
            // подія SceneReady не прийде — відкриваємо головне меню локально.
            if (SceneManager.GetActiveScene().name == SceneFlow.Menu)
                ShowMain();
        }

        private void OnEnable()
        {
            // Відкриття екранів
            EventBus.Subscribe<MenuEvents.OpenMainMenu>(OnOpenMain);
            EventBus.Subscribe<MenuEvents.OpenSettings>(OnOpenSettings);
            EventBus.Subscribe<MenuEvents.OpenLevelSelection>(OnOpenLevels);
            EventBus.Subscribe<MenuEvents.BackRequested>(OnBack);

            // Дії
            EventBus.Subscribe<MenuEvents.QuitRequested>(OnQuit);
            EventBus.Subscribe<MenuEvents.StartGameRequested>(OnStartGame);
            EventBus.Subscribe<MenuEvents.LevelChosen>(OnLevelChosen);

            // Коли меню-сцена готова (через LoadingScreen) — показати головне меню
            EventBus.Subscribe<SceneReady>(OnSceneReady);
        }

        private void OnDisable()
        {
            EventBus.Unsubscribe<MenuEvents.OpenMainMenu>(OnOpenMain);
            EventBus.Unsubscribe<MenuEvents.OpenSettings>(OnOpenSettings);
            EventBus.Unsubscribe<MenuEvents.OpenLevelSelection>(OnOpenLevels);
            EventBus.Unsubscribe<MenuEvents.BackRequested>(OnBack);

            EventBus.Unsubscribe<MenuEvents.QuitRequested>(OnQuit);
            EventBus.Unsubscribe<MenuEvents.StartGameRequested>(OnStartGame);
            EventBus.Unsubscribe<MenuEvents.LevelChosen>(OnLevelChosen);

            EventBus.Unsubscribe<SceneReady>(OnSceneReady);
        }

        // ---------- Event handlers ----------
        private void OnSceneReady(SceneReady e)
        {
            if (e.Name == SceneFlow.Menu)
                ShowMain();
        }

        private void OnOpenMain(MenuEvents.OpenMainMenu _)=> ShowMain();
        private void OnOpenSettings(MenuEvents.OpenSettings _)=> ShowSettings();
        private void OnOpenLevels(MenuEvents.OpenLevelSelection _)=> ShowLevels();
        private void OnBack(MenuEvents.BackRequested _)=> ShowMain();

        private void OnQuit(MenuEvents.QuitRequested _)
        {
            Application.Quit();
#if UNITY_EDITOR
            UnityEditor.EditorApplication.isPlaying = false;
#endif
        }

        private void OnStartGame(MenuEvents.StartGameRequested _)
        {
            SceneFlow.GoToGame(startGameFakeFinish);
        }

        private void OnLevelChosen(MenuEvents.LevelChosen e)
        {
            // TODO: зберегти e.LevelId у своєму GameData/Session, якщо потрібно
            SceneFlow.GoToGame(startGameFakeFinish);
        }

        // ---------- UI switching ----------
        private void HideAll()
        {
            if (mainMenuPopup) mainMenuPopup.HideView();
            if (settingsPopup) settingsPopup.HideView();
            if (levelSelectionPopup) levelSelectionPopup.HideView();
        }

        private void ShowMain()
        {
            if (_transitioning || _current == Panel.Main) return;
            _transitioning = true;
            HideAll();
            mainMenuPopup?.ShowView();
            _current = Panel.Main;
            _transitioning = false;
        }

        private void ShowSettings()
        {
            if (_transitioning || _current == Panel.Settings) return;
            _transitioning = true;
            HideAll();
            settingsPopup?.ShowView();
            _current = Panel.Settings;
            _transitioning = false;
        }

        private void ShowLevels()
        {
            if (_transitioning || _current == Panel.Levels) return;
            _transitioning = true;
            HideAll();
            levelSelectionPopup?.ShowView();
            _current = Panel.Levels;
            _transitioning = false;
        }
    }

    // Події меню тримаєш у окремому файлі MenuEvents.cs (як у тебе зараз).
}


========== FILE: MenuEvents.cs ==========
namespace Menu.UI
{
    public class MenuEvents
    {
        public readonly struct OpenMainMenu { }
        public readonly struct OpenSettings { }
        public readonly struct OpenLevelSelection { }
        public readonly struct BackRequested { }
        public readonly struct QuitRequested { }
        public readonly struct StartGameRequested { }
        public readonly struct LevelChosen
        {
            public readonly string LevelId;
            public LevelChosen(string levelId) => LevelId = levelId;
        }
    }
}

========== FILE: LevelsConfig.cs ==========
using System;

namespace Core.GamePlay.Levels
{
    [Serializable]
    public class LevelData
    {
        // Які символи спавнити по порядку (індекси в масиві symbolPrefabs)
        public int[] symbolPrefabIndices;

        // Параметри складності для цього рівня
        public float moveSpeed = 5f;
        public float stopDuration = 0.5f;
        public float hitWindow = 0.3f;
    }

    [Serializable]
    public class LevelsFile
    {
        public LevelData[] levels;
    }
}

========== FILE: SymbolNode.cs ==========
using UnityEngine;

namespace Core.GamePlay.Symboll
{
    public class SymbolNode : MonoBehaviour
    {
        [Header("Visuals")]
        public SpriteRenderer sprite;
        public Color idleColor = Color.white;
        public Color activeColor = Color.yellow;

        [Header("Highlight Settings")]
        [SerializeField] private float highlightScaleMul = 1.1f;

        private bool _activated;
        private Vector3 _baseScale;

        void Reset()
        {
            sprite = GetComponentInChildren<SpriteRenderer>();
        }

        void Awake()
        {
            // базовий scale
            _baseScale = transform.localScale;

            // МОЖНА тут скинути стан один раз при створенні
            SetIdle();
            SetHighlighted(false);
        }

        // ❌ Start прибираємо зовсім, або залишаємо пустим
        // void Start() { }

        public void SetIdle()
        {
            _activated = false;
            if (sprite != null)
                sprite.color = idleColor;
        }

        public void Activate()
        {
            _activated = true;
            if (sprite != null)
                sprite.color = activeColor;
        }

        public bool IsActivated => _activated;

        public void SetHighlighted(bool highlighted)
        {
            transform.localScale = highlighted
                ? _baseScale * highlightScaleMul
                : _baseScale;
        }
    }
}

========== FILE: GameplayHud.cs ==========
// Assets/Scripts/Core/GamePlay/UI/GameplayHud.cs
using Core.EventBusSystem;
using UnityEngine;
using UnityEngine.UI;
using Menu.UI.Popups;
using TMPro; // BasePopup

namespace Core.GamePlay.UI
{
    public sealed class GameplayHud : BasePopup
    {
        [Header("Buttons")]
        [SerializeField] private Button pauseButton;

        [Header("Texts")]
        [SerializeField] private TextMeshProUGUI levelText; // або TMP_Text, якщо хочеш — тоді поміняй тип

        protected override void Awake()
        {
            base.Awake();

            if (pauseButton)
                pauseButton.onClick.AddListener(OnPauseClicked);
        }

        private void OnDestroy()
        {
            if (pauseButton)
                pauseButton.onClick.RemoveListener(OnPauseClicked);
        }

        private void OnPauseClicked()
        {
            EventBus.Invoke(new GameEvents.PauseRequested());
        }

        public void SetLevel(int levelNumber)
        {
            if (!levelText) return;
            levelText.text = $"Level {levelNumber}";
        }
    }
}

========== FILE: GameUIManager.cs ==========
// Assets/Scripts/Core/GamePlay/UI/GameUIManager.cs
using Core.EventBusSystem;
using UnityEngine;

namespace Core.GamePlay.UI
{
    public sealed class GameUIManager : MonoBehaviour
    {
        [Header("Views")]
        [SerializeField] private GameplayHud gameplayHud;
        [SerializeField] private PausePopup pausePopup;
        [SerializeField] private WinPopup winPopup;
        [SerializeField] private LosePopup losePopup;

        private void Awake()
        {
            // стартовий стан:
            if (pausePopup) pausePopup.HideView();
            if (winPopup)   winPopup.HideView();
            if (losePopup)  losePopup.HideView();
            if (gameplayHud) gameplayHud.ShowView();
        }

        private void OnEnable()
        {
            EventBus.Subscribe<GameEvents.PauseRequested>(OnPauseRequested);
            EventBus.Subscribe<GameEvents.ResumeRequested>(OnResumeRequested);
            EventBus.Subscribe<GameEvents.LevelCompleted>(OnLevelCompleted);
            EventBus.Subscribe<GameEvents.LevelFailed>(OnLevelFailed);
        }

        private void OnDisable()
        {
            EventBus.Unsubscribe<GameEvents.PauseRequested>(OnPauseRequested);
            EventBus.Unsubscribe<GameEvents.ResumeRequested>(OnResumeRequested);
            EventBus.Unsubscribe<GameEvents.LevelCompleted>(OnLevelCompleted);
            EventBus.Unsubscribe<GameEvents.LevelFailed>(OnLevelFailed);
        }

        void OnPauseRequested(GameEvents.PauseRequested _)
        {
            if (pausePopup) pausePopup.ShowView();
        }

        void OnResumeRequested(GameEvents.ResumeRequested _)
        {
            if (pausePopup) pausePopup.HideView();
        }

        void OnLevelCompleted(GameEvents.LevelCompleted _)
        {
            if (pausePopup) pausePopup.HideView();
            if (winPopup)   winPopup.ShowView();
        }

        void OnLevelFailed(GameEvents.LevelFailed _)
        {
            if (pausePopup) pausePopup.HideView();
            if (losePopup)  losePopup.ShowView();
        }
    }
}


========== FILE: LosePopup.cs ==========
// Assets/Scripts/Core/GamePlay/UI/LosePopup.cs
using Core.EventBusSystem;
using UnityEngine;
using UnityEngine.UI;
using Menu.UI.Popups;

namespace Core.GamePlay.UI
{
    public sealed class LosePopup : BasePopup
    {
        [SerializeField] private Button restartButton;
        [SerializeField] private Button menuButton;

        protected override void Awake()
        {
            base.Awake();

            if (restartButton) restartButton.onClick.AddListener(OnRestartClicked);
            if (menuButton)    menuButton.onClick.AddListener(OnMenuClicked);
        }

        private void OnDestroy()
        {
            if (restartButton) restartButton.onClick.RemoveListener(OnRestartClicked);
            if (menuButton)    menuButton.onClick.RemoveListener(OnMenuClicked);
        }

        private void OnRestartClicked()
        {
            EventBus.Invoke(new GameEvents.RestartRequested());
        }

        private void OnMenuClicked()
        {
            EventBus.Invoke(new GameEvents.GoToMenuRequested());
        }
    }
}

========== FILE: PausePopup.cs ==========
// Assets/Scripts/Core/GamePlay/UI/PausePopup.cs
using Core.EventBusSystem;
using UnityEngine;
using UnityEngine.UI;
using Menu.UI.Popups;

namespace Core.GamePlay.UI
{
    public sealed class PausePopup : BasePopup
    {
        [Header("Buttons")]
        [SerializeField] private Button resumeButton;
        [SerializeField] private Button restartButton;
        [SerializeField] private Button menuButton;

        protected override void Awake()
        {
            base.Awake();

            if (resumeButton)  resumeButton.onClick.AddListener(OnResumeClicked);
            if (restartButton) restartButton.onClick.AddListener(OnRestartClicked);
            if (menuButton)    menuButton.onClick.AddListener(OnMenuClicked);
        }

        private void OnDestroy()
        {
            if (resumeButton)  resumeButton.onClick.RemoveListener(OnResumeClicked);
            if (restartButton) restartButton.onClick.RemoveListener(OnRestartClicked);
            if (menuButton)    menuButton.onClick.RemoveListener(OnMenuClicked);
        }

        private void OnResumeClicked()
        {
            EventBus.Invoke(new GameEvents.ResumeRequested());
        }

        private void OnRestartClicked()
        {
            EventBus.Invoke(new GameEvents.RestartRequested());
        }

        private void OnMenuClicked()
        {
            EventBus.Invoke(new GameEvents.GoToMenuRequested());
        }
    }
}

========== FILE: WinPopup.cs ==========
// Assets/Scripts/Core/GamePlay/UI/WinPopup.cs
using Core.EventBusSystem;
using UnityEngine;
using UnityEngine.UI;
using Menu.UI.Popups;

namespace Core.GamePlay.UI
{
    public sealed class WinPopup : BasePopup
    {
        [Header("Buttons")]
        [SerializeField] private Button nextLevelButton;
        [SerializeField] private Button menuButton;

        protected override void Awake()
        {
            base.Awake();

            if (nextLevelButton)
                nextLevelButton.onClick.AddListener(OnNextClicked);

            if (menuButton)
                menuButton.onClick.AddListener(OnMenuClicked);
        }

        private void OnDestroy()
        {
            if (nextLevelButton)
                nextLevelButton.onClick.RemoveListener(OnNextClicked);

            if (menuButton)
                menuButton.onClick.RemoveListener(OnMenuClicked);
        }

        private void OnNextClicked()
        {
            EventBus.Invoke(new GameEvents.NextLevelRequested());
        }

        private void OnMenuClicked()
        {
            EventBus.Invoke(new GameEvents.GoToMenuRequested());
        }
    }
}

========== FILE: BasePopup.cs ==========
using DG.Tweening;
using UnityEngine;

namespace Menu.UI.Popups
{
    public class BasePopup : MonoBehaviour
    {
        [SerializeField] protected Transform content;
        [SerializeField] protected CanvasGroup canvasGroup;
        [SerializeField] private float animationDuration = 0.5f;

        private Tween _fadeTween;

        // ВАЖЛИВО: НІЯКОГО Initial() В AWAKE!
        // Стан початкової видимості задаєш у префабі/сцені.
        protected virtual void Awake()
        {
            Debug.Log($"[Popup] Awake {name} (content.activeSelf={content?.gameObject.activeSelf}, alpha={canvasGroup?.alpha})", this);

            if (!canvasGroup)
                Debug.LogWarning($"[Popup] {name} CanvasGroup НЕ заданий", this);
            if (!content)
                Debug.LogWarning($"[Popup] {name} Content НЕ заданий", this);
        }

        protected virtual void OnDisable()
        {
            if (_fadeTween != null && _fadeTween.IsActive())
                _fadeTween.Kill();
        }

        public virtual void ShowView()
        {
            Debug.Log($"[Popup] ShowView {name}", this);

            if (_fadeTween != null && _fadeTween.IsActive())
                _fadeTween.Kill();

            if (content) content.gameObject.SetActive(true);

            if (canvasGroup)
            {
                canvasGroup.interactable = true;
                canvasGroup.blocksRaycasts = true;

                // миттєво піднімаємо alpha до 1, або хочеш — залиш tween
                _fadeTween = canvasGroup.DOFade(1f, animationDuration)
                    .SetEase(Ease.OutQuad)
                    .SetUpdate(true)
                    .OnComplete(() => canvasGroup.alpha = 1f);
            }
        }

        public virtual void HideView()
        {
            Debug.Log($"[Popup] HideView {name}", this);

            if (_fadeTween != null && _fadeTween.IsActive())
                _fadeTween.Kill();

            if (canvasGroup)
            {
                _fadeTween = canvasGroup.DOFade(0f, animationDuration)
                    .SetEase(Ease.InQuad)
                    .SetUpdate(true)
                    .OnComplete(() =>
                    {
                        if (content) content.gameObject.SetActive(false);
                        canvasGroup.interactable = false;
                        canvasGroup.blocksRaycasts = false;
                    });
            }
            else
            {
                if (content) content.gameObject.SetActive(false);
            }
        }
    }
}


========== FILE: LevelSelectionPopup.cs ==========
using System;
using Core.EventBusSystem;
using UnityEngine;
using UnityEngine.UI;
// LevelChosen, BackRequested

namespace Menu.UI.Popups
{
    public sealed class LevelSelectionPopup : BasePopup
    {
        [Serializable]
        private struct LevelEntry
        {
            public Button button;   // кнопка рівня
            public string levelId;  // або sceneName (як тобі зручніше)
        }

        [Header("Buttons")]
        [SerializeField] private LevelEntry[] levels;
        [SerializeField] private Button backButton;

        protected override void Awake()
        {
            base.Awake();

            if (levels != null)
            {
                for (int i = 0; i < levels.Length; i++)
                {
                    var entry = levels[i]; // копія для коректного замикання
                    if (entry.button)
                        entry.button.onClick.AddListener(() => OnLevelClicked(entry.levelId));
                }
            }

            if (backButton) backButton.onClick.AddListener(OnBackClicked);
        }

        private void OnDestroy()
        {
            if (levels != null)
            {
                for (int i = 0; i < levels.Length; i++)
                {
                    var entry = levels[i];
                    if (entry.button)
                        entry.button.onClick.RemoveAllListeners(); // або зберігати делегати і знімати точково
                }
            }

            if (backButton) backButton.onClick.RemoveListener(OnBackClicked);
        }

        private void OnLevelClicked(string levelId)
        {
            EventBus.Invoke(new MenuEvents.LevelChosen(levelId));
            // або, якщо стартуєш без збереження id:
            // EventBus.Invoke(new StartGameRequested());
        }

        private void OnBackClicked() => EventBus.Invoke(new MenuEvents.BackRequested());
    }
}

========== FILE: MainMenuPopup.cs ==========
using Core.EventBusSystem;
using UnityEngine;
using UnityEngine.UI;
// OpenSettings, OpenLevelSelection, QuitRequested, StartGameRequested (якщо треба)

namespace Menu.UI.Popups
{
    public sealed class MainMenuPopup : BasePopup
    {
        [Header("Buttons")]
        [SerializeField] private Button settingsButton;
        [SerializeField] private Button levelSelectButton;


        [SerializeField] private Button quitButton;

        protected override void Awake()
        {
            base.Awake();

            if (settingsButton)     settingsButton.onClick.AddListener(OnSettingsClicked);
            if (levelSelectButton)  levelSelectButton.onClick.AddListener(OnLevelSelectClicked);
            if (quitButton)         quitButton.onClick.AddListener(OnQuitClicked);
        }

        private void OnDestroy()
        {
            if (settingsButton)     settingsButton.onClick.RemoveListener(OnSettingsClicked);
            if (levelSelectButton)  levelSelectButton.onClick.RemoveListener(OnLevelSelectClicked);
            if (quitButton)         quitButton.onClick.RemoveListener(OnQuitClicked);
        }

        private void OnSettingsClicked()    => EventBus.Invoke(new MenuEvents.OpenSettings());
        private void OnLevelSelectClicked() => EventBus.Invoke(new MenuEvents.OpenLevelSelection());
        private void OnQuitClicked()        => EventBus.Invoke(new MenuEvents.QuitRequested());
    }
}

========== FILE: SettingsPopup.cs ==========
// Assets/Scripts/Menu/UI/Popups/SettingsPopup.cs
using Core.EventBusSystem;
using Core.Settings;
using UnityEngine;
using UnityEngine.UI;

namespace Menu.UI.Popups
{
    public sealed class SettingsPopup : BasePopup
    {
        [Header("Buttons")]
        [SerializeField] private Button backButton;

        [Header("Toggles")]
        [SerializeField] private Toggle musicToggle;
        [SerializeField] private Toggle sfxToggle;

        private bool _lockUi; 

        protected override void Awake()
        {
            base.Awake();

            if (backButton) backButton.onClick.AddListener(OnBackClicked);

            if (musicToggle) musicToggle.onValueChanged.AddListener(OnMusicToggle);
            if (sfxToggle)   sfxToggle.onValueChanged.AddListener(OnSfxToggle);
        }

        private void OnEnable()
        {
            EventBus.Subscribe<SettingsLoaded>(OnSettings);
            EventBus.Subscribe<SettingsChanged>(OnSettings);
            
            EventBus.Invoke(new SettingsSyncRequested());
        }

        protected override void OnDisable()
        {
            EventBus.Unsubscribe<SettingsLoaded>(OnSettings);
            EventBus.Unsubscribe<SettingsChanged>(OnSettings);
        }

        private void OnDestroy()
        {
            if (backButton)  backButton.onClick.RemoveListener(OnBackClicked);
            if (musicToggle) musicToggle.onValueChanged.RemoveListener(OnMusicToggle);
            if (sfxToggle)   sfxToggle.onValueChanged.RemoveListener(OnSfxToggle);
        }

        private void OnBackClicked() => EventBus.Invoke(new Menu.UI.MenuEvents.BackRequested());

        private void OnMusicToggle(bool isOn)
        {
            if (_lockUi) return;
            EventBus.Invoke(new MusicToggleRequested(isOn));
        }

        private void OnSfxToggle(bool isOn)
        {
            if (_lockUi) return;
            EventBus.Invoke(new SfxToggleRequested(isOn));
        }

        private void OnSettings(SettingsLoaded e)  => SyncUI(e.MusicOn, e.SfxOn);
        private void OnSettings(SettingsChanged e) => SyncUI(e.MusicOn, e.SfxOn);

        private void SyncUI(bool musicOn, bool sfxOn)
        {
            _lockUi = true;
            if (musicToggle) musicToggle.SetIsOnWithoutNotify(musicOn);
            if (sfxToggle)   sfxToggle.SetIsOnWithoutNotify(sfxOn);
            _lockUi = false;
        }
    }
}


