========== FILE: AudioService.cs ==========
// Assets/Scripts/Core/Audio/AudioService.cs
using Core.EventBusSystem;
using Core.Settings;
using Core.SceneManagement;
using UnityEngine;
using UnityEngine.Audio;

namespace Core.Audio
{
    [DefaultExecutionOrder(-120)]
    public sealed class AudioService : MonoBehaviour
    {
        public static AudioService Instance { get; private set; }

        [Header("Mixer")]
        [SerializeField] private AudioMixer masterMixer;
        [SerializeField] private string musicParam = "MusicVolume";
        [SerializeField] private string sfxParam   = "SFXVolume";

        [Header("Volumes (dB)")]
        [SerializeField] private float onDb  = 0f;
        [SerializeField] private float offDb = -80f;

        // ❌ повністю видалено RuntimeInitializeOnLoadMethod + самостворення!

        private void Awake()
        {
            if (Instance != null && Instance != this) { Destroy(gameObject); return; }
            Instance = this;
            DontDestroyOnLoad(gameObject);

            // fallback: якщо міксер не підв’язаний у префабі — спробуємо дістати з Resources
            if (!masterMixer)
                masterMixer = Resources.Load<AudioMixer>("Audio/MasterMixer");

            if (!masterMixer)
                Debug.LogError("[AudioService] No AudioMixer assigned/found. Assign in prefab or put at Resources/Audio/MasterMixer.mixer");
        }

        private void OnEnable()
        {
            EventBus.Subscribe<SettingsLoaded>(OnSettingsLoaded);
            EventBus.Subscribe<SettingsChanged>(OnSettingsChanged);
            EventBus.Subscribe<SceneReady>(OnSceneReady);

            // одразу синхронізуємо стан (раптом пропустили ранні події)
            EventBus.Invoke(new SettingsSyncRequested());
        }

        private void OnDisable()
        {
            EventBus.Unsubscribe<SettingsLoaded>(OnSettingsLoaded);
            EventBus.Unsubscribe<SettingsChanged>(OnSettingsChanged);
            EventBus.Unsubscribe<SceneReady>(OnSceneReady);
        }

        private void OnSettingsLoaded(SettingsLoaded e)  => Apply(e.MusicOn, e.SfxOn);
        private void OnSettingsChanged(SettingsChanged e) => Apply(e.MusicOn, e.SfxOn);

        private void OnSceneReady(SceneReady _)
        {
            EventBus.Invoke(new SettingsSyncRequested());
        }

        private void Apply(bool musicOn, bool sfxOn)
        {
            if (!masterMixer)
            {
                Debug.LogWarning("[AudioService] No AudioMixer assigned.");
                return;
            }
            masterMixer.SetFloat(musicParam, musicOn ? onDb : offDb);
            masterMixer.SetFloat(sfxParam,   sfxOn   ? onDb : offDb);
        }
    }
}


========== FILE: EventBus.cs ==========
using System;
using System.Collections.Generic;

namespace Core.EventBusSystem
{
    public static class EventBus
    {
        private static readonly Dictionary<Type, List<Delegate>> _subscribers = new();

        public static void Subscribe<T>(Action<T> callback)
        {
            var type = typeof(T);
            if (!_subscribers.ContainsKey(type))
                _subscribers[type] = new List<Delegate>();

            _subscribers[type].Add(callback);
        }

        public static void Unsubscribe<T>(Action<T> callback)
        {
            var type = typeof(T);
            if (_subscribers.TryGetValue(type, out var list))
            {
                list.Remove(callback);
                if (list.Count == 0)
                    _subscribers.Remove(type);
            }
        }

        public static void Invoke<T>(T eventData)
        {
            var type = typeof(T);
            if (_subscribers.TryGetValue(type, out var list))
            {
                var snapshot = list.ToArray(); 
                for (int i = 0; i < snapshot.Length; i++)
                    (snapshot[i] as Action<T>)?.Invoke(eventData);
            }
        }

    }
}

========== FILE: IState.cs ==========
namespace Core.FSM
{
    public interface IState
    {
        void Enter();
        void Exit();
        void Update();
    }
}


========== FILE: StateMachine.cs ==========
namespace Core.FSM
{
    public sealed class StateMachine
    {
        private IState _current;
        public IState Current => _current;

        public void Change(IState next)
        {
            if (_current == next) return;
            _current?.Exit();
            _current = next;
            _current?.Enter();
        }

        public void Update() => _current?.Update();
    }
}

========== FILE: GameManager.cs ==========
using System.Collections.Generic;
using Core.GamePlay.Levels;
using Core.GamePlay.Symboll;
using UnityEngine;

namespace Core.GamePlay
{
    public class GameManager : MonoBehaviour
    {
        [Header("Refs")]
        public SunBeamController beam;

        [Tooltip("Позиції, де можуть спавнитись символи (по порядку).")]
        public Transform[] spawnPoints;

        [Tooltip("Всі види символів (префаби).")]
        public SymbolNode[] symbolPrefabs;

        [Header("Levels config file (JSON)")]
        public TextAsset levelsJson;   // сюди закинемо файл

        LevelsFile _levelsFile;
        LevelData _currentLevel;

        public int currentLevelIndex = 0;

        List<SymbolNode> _spawnedSymbols = new List<SymbolNode>();

        void Start()
        {
            if (!beam)
            {
                Debug.LogError("GameManager: beam not set!");
                enabled = false;
                return;
            }

            if (!levelsJson)
            {
                Debug.LogError("GameManager: levelsJson (TextAsset) is not assigned!");
                enabled = false;
                return;
            }

            // розпарсити JSON
            _levelsFile = JsonUtility.FromJson<LevelsFile>(levelsJson.text);
            if (_levelsFile == null || _levelsFile.levels == null || _levelsFile.levels.Length == 0)
            {
                Debug.LogError("GameManager: no levels in JSON!");
                enabled = false;
                return;
            }

            if (currentLevelIndex < 0 || currentLevelIndex >= _levelsFile.levels.Length)
            {
                currentLevelIndex = 0;
            }

            _currentLevel = _levelsFile.levels[currentLevelIndex];

            SetupLevel();
        }

        void SetupLevel()
        {
            // видалити старі символи, якщо були
            foreach (var s in _spawnedSymbols)
            {
                if (s != null)
                    Destroy(s.gameObject);
            }
            _spawnedSymbols.Clear();

            if (_currentLevel.symbolPrefabIndices == null || _currentLevel.symbolPrefabIndices.Length == 0)
            {
                Debug.LogError("Current level has no symbolPrefabIndices!");
                return;
            }

            int count = Mathf.Min(_currentLevel.symbolPrefabIndices.Length, spawnPoints.Length);
            Transform[] beamPoints = new Transform[count];

            for (int i = 0; i < count; i++)
            {
                int prefabIndex = _currentLevel.symbolPrefabIndices[i];

                if (prefabIndex < 0 || prefabIndex >= symbolPrefabs.Length)
                {
                    Debug.LogError($"Invalid prefab index {prefabIndex} in level {currentLevelIndex}");
                    continue;
                }

                SymbolNode prefab = symbolPrefabs[prefabIndex];
                Transform point = spawnPoints[i];

                SymbolNode instance = Instantiate(prefab, point.position, Quaternion.identity);
                instance.SetIdle();

                _spawnedSymbols.Add(instance);
                beamPoints[i] = instance.transform;
            }

            // запускаємо промінь з параметрами рівня
            beam.Init(beamPoints, _currentLevel);
        }

        void Update()
        {
            bool pressed = false;

            if (Input.GetKeyDown(KeyCode.Space) || Input.GetMouseButtonDown(0))
                pressed = true;

#if UNITY_ANDROID || UNITY_IOS
            if (Input.touchCount > 0 && Input.GetTouch(0).phase == TouchPhase.Began)
                pressed = true;
#endif

            if (pressed)
                OnPlayerClick();
        }

        void OnPlayerClick()
        {
            if (!beam.IsInStopWindow)
            {
                Debug.Log("Click outside hit window");
                return;
            }

            int idx = beam.CurrentIndex;
            if (idx < 0 || idx >= _spawnedSymbols.Count)
                return;

            SymbolNode node = _spawnedSymbols[idx];

            if (!node.IsActivated)
            {
                node.Activate();
                Debug.Log($"Symbol {idx} activated!");
            }
            else
            {
                Debug.Log($"Symbol {idx} already active.");
            }
        }
    }
}


========== FILE: SunBeamController.cs ==========
using System.Collections;
using UnityEngine;
using Core.GamePlay.Levels;   // <<< важливо

namespace Core.GamePlay
{
    public class SunBeamController : MonoBehaviour
    {
        float _moveSpeed;
        float _stopDuration;
        float _hitWindow;
        float _reachDistance = 0.05f;

        Transform[] _points;

        public bool IsInStopWindow { get; private set; }
        public int CurrentIndex { get; private set; } = -1;

        Coroutine _routine;

        // викликається з GameManager
        public void Init(Transform[] points, LevelData levelData)   // <<< тут теж
        {
            _points = points;

            if (_points == null || _points.Length == 0)
            {
                Debug.LogError("SunBeamController.Init: no points!");
                return;
            }

            _moveSpeed    = levelData.moveSpeed;
            _stopDuration = levelData.stopDuration;
            _hitWindow    = levelData.hitWindow;

            transform.position = _points[0].position;
            IsInStopWindow = false;
            CurrentIndex = -1;

            if (_routine != null)
                StopCoroutine(_routine);

            _routine = StartCoroutine(MoveRoutine());
        }

        IEnumerator MoveRoutine()
        {
            for (int i = 0; i < _points.Length; i++)
            {
                Transform target = _points[i];

                while (Vector3.Distance(transform.position, target.position) > _reachDistance)
                {
                    transform.position = Vector3.MoveTowards(
                        transform.position,
                        target.position,
                        _moveSpeed * Time.deltaTime
                    );
                    yield return null;
                }

                CurrentIndex = i;

                IsInStopWindow = true;
                yield return new WaitForSeconds(_hitWindow);

                IsInStopWindow = false;
                float rest = Mathf.Max(0f, _stopDuration - _hitWindow);
                yield return new WaitForSeconds(rest);
            }

            Debug.Log("Beam: sequence finished");
        }
    }
}


========== FILE: Bootstrap.cs ==========
// Assets/Scripts/Core/SceneManagement/Bootstrap.cs
using UnityEngine;
using Core.Audio; // ← додай

namespace Core.SceneManagement
{
    public static class Bootstrap
    {
        private const string LoadingScreenResPath = "UI/LoadingScreen";
        private const string AudioServiceResPath  = "Systems/AudioService"; // ← нове

        private const string MainMenuScene = "MainMenuScene";
        private const float  FirstShowDelay = 2.0f;

        //[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
        private static void Init()
        {
            // LoadingScreen
            if (LoadingScreen.Instance == null)
            {
                var prefab = Resources.Load<LoadingScreen>(LoadingScreenResPath);
                if (prefab != null) Object.Instantiate(prefab);
                else Debug.LogError("[Bootstrap] Missing Resources/UI/LoadingScreen.prefab with LoadingScreen component.");
            }

            // AudioService (без самостворення всередині сервісу)
            if (AudioService.Instance == null)
            {
                var audioPrefab = Resources.Load<AudioService>(AudioServiceResPath);
                if (audioPrefab != null) Object.Instantiate(audioPrefab);
                else Debug.LogError("[Bootstrap] Missing Resources/Systems/AudioService.prefab with AudioService component.");
            }

            // нормалізація часу (за бажанням)
            // Time.timeScale = 1f;

            LoadingScreen.Instance?.LoadScene(MainMenuScene, FirstShowDelay);
        }
    }
}

========== FILE: LoadingScreen.cs ==========
using System.Collections;
using Core.EventBusSystem;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.UI;
// ✨ додали
using Core.SceneManagement;    // ✨ додали (для SceneLoadingStarted/Loaded/Ready)

namespace Core.SceneManagement
{
    [DefaultExecutionOrder(-100)]
    public sealed class LoadingScreen : MonoBehaviour
    {
        public static LoadingScreen Instance { get; private set; }

        [Header("UI")]
        [SerializeField] private GameObject root;     // контейнер екрана завантаження
        [SerializeField] private Slider progressBar;  // індикатор прогресу (0..1)

        [Header("Config (Inspector)")]
        [SerializeField, Tooltip("Швидкість згладжування заповнення (візуально).")]
        private float smoothSpeed = 6f;

        // Значення за замовчуванням (якщо Bootstrap не передасть оверрайд)
        private const float DefaultFakeFinishTime = 1.0f;

        private Coroutine _routine;
        private bool _isLoading;
        private string _targetScene;

        private void Awake()
        {
            if (Instance != null && Instance != this) { Destroy(gameObject); return; }
            Instance = this;
            DontDestroyOnLoad(gameObject);

            if (root) root.SetActive(false);
            if (progressBar) progressBar.value = 0f;
        }

        /// <summary>
        /// Завантажує сцену з екраном завантаження.
        /// fakeDelayOverride — тривалість штучної фази 75% → 100% (сек), зазвичай задається Bootstrap-ом.
        /// </summary>
        public void LoadScene(string sceneName, float? fakeDelayOverride = null)
        {
            if (string.IsNullOrWhiteSpace(sceneName))
            {
                Debug.LogError("[LoadingScreen] Scene name is null or empty.");
                return;
            }

            // якщо намагаємось завантажити активну сцену — нічого не робимо
            if (SceneManager.GetActiveScene().name == sceneName)
            {
                Debug.LogWarning($"[LoadingScreen] Scene '{sceneName}' is already active.");
                root?.SetActive(false);
                return;
            }

            // перевірка на наявність у Build Settings
            if (!Application.CanStreamedLevelBeLoaded(sceneName))
            {
                Debug.LogError($"[LoadingScreen] Scene '{sceneName}' is not in Build Settings.");
                return;
            }

            // захист від повторних викликів одного й того ж лоаду
            if (_isLoading && _targetScene == sceneName)
                return;

            if (_routine != null) StopCoroutine(_routine);

            _isLoading = true;
            _targetScene = sceneName;

            root?.SetActive(true);
            if (progressBar) progressBar.value = 0f;

            float fakeDelay = fakeDelayOverride ?? DefaultFakeFinishTime;
            _routine = StartCoroutine(LoadSceneRoutine(sceneName, fakeDelay));
        }

        private IEnumerator LoadSceneRoutine(string sceneName, float fakeDelay)
        {
            // дати Canvas відмалюватися перед стартом важкого лоаду
            Canvas.ForceUpdateCanvases();
            yield return null;

            // ✨ нове: кинули подію "почали завантаження сцени"
            EventBus.Invoke(new SceneLoadingStarted(sceneName));

            var async = SceneManager.LoadSceneAsync(sceneName);
            async.allowSceneActivation = false;

            float shown = 0f;
            const float realPhaseMax = 0.75f; // до 75% — реальний прогрес
            const float unityCap     = 0.9f;  // Unity звітує 0.9 до активації

            // --- ФАЗА 1: реальний прогрес (0–75%) ---
            while (async.progress < unityCap)
            {
                float normalized = Mathf.Clamp01(async.progress / unityCap); // 0..1
                float target = normalized * realPhaseMax;                    // 0..0.75
                shown = Mathf.MoveTowards(shown, target, Time.unscaledDeltaTime * smoothSpeed);

                if (progressBar) progressBar.value = shown;
                yield return null;
            }

            // --- ФАЗА 2: штучна затримка 75–100% ---
            float timer = 0f;
            while (timer < fakeDelay)
            {
                timer += Time.unscaledDeltaTime;
                float t = Mathf.Clamp01(timer / fakeDelay);
                float target = Mathf.Lerp(realPhaseMax, 1f, t); // 0.75 → 1.0 за fakeDelay
                shown = Mathf.MoveTowards(shown, target, Time.unscaledDeltaTime * smoothSpeed);

                if (progressBar) progressBar.value = shown;
                yield return null;
            }

            // гарантувати 100% і дати один кадр завершення
            if (progressBar) progressBar.value = 1f;
            yield return null;

            // --- Активуємо сцену ---
            async.allowSceneActivation = true;
            while (!async.isDone) yield return null;

            // ✨ нове: повідомили, що сцена активована
            EventBus.Invoke(new SceneLoaded(sceneName));
            // ✨ нове: ще один кадр — даємо Awake/Start у новій сцені відпрацювати
            yield return null;
            // ✨ нове: тепер сцена гарантовано "готова" для UI/контролерів
            EventBus.Invoke(new SceneReady(sceneName));

            // короткий буфер, щоб уникнути "блимання" на дуже швидких сценах
            yield return new WaitForSecondsRealtime(0.2f);

            if (root) root.SetActive(false);
            _isLoading = false;
            _targetScene = null;
            _routine = null;
        }
    }
}


========== FILE: SceneEvents.cs ==========
namespace Core.SceneManagement
{
    public readonly struct SceneLoadingStarted { public readonly string Target; public SceneLoadingStarted(string t)=>Target=t; }
    public readonly struct SceneLoaded        { public readonly string Name;   public SceneLoaded(string n)=>Name=n; }
    public readonly struct SceneReady         { public readonly string Name;   public SceneReady(string n)=>Name=n; }
}

========== FILE: SceneFlow.cs ==========
namespace Core.SceneManagement
{
    public static class SceneFlow
    {
        public const string Menu = "MainMenuScene";
        public const string Game = "GameScene";

        public static void GoToMenu(float? fake = null) => LoadingScreen.Instance?.LoadScene(Menu, fake);
        public static void GoToGame(float? fake = null) => LoadingScreen.Instance?.LoadScene(Game, fake);
    }
}

========== FILE: SettingsEvents.cs ==========
namespace Core.Settings
{
    public readonly struct SettingsLoaded
    {
        public readonly bool MusicOn;
        public readonly bool SfxOn;
        public SettingsLoaded(bool musicOn, bool sfxOn) { MusicOn = musicOn; SfxOn = sfxOn; }
    }
    
    public readonly struct SettingsChanged
    {
        public readonly bool MusicOn;
        public readonly bool SfxOn;
        public SettingsChanged(bool musicOn, bool sfxOn) { MusicOn = musicOn; SfxOn = sfxOn; }
    }
    
    public readonly struct MusicToggleRequested { public readonly bool IsOn; public MusicToggleRequested(bool isOn) { IsOn = isOn; } }
    public readonly struct SfxToggleRequested   { public readonly bool IsOn; public SfxToggleRequested(bool isOn)   { IsOn = isOn; } }
    
    public readonly struct SettingsSyncRequested { }
}

========== FILE: SettingsService.cs ==========
// Assets/Scripts/Core/Settings/SettingsService.cs
using Core.EventBusSystem;
using UnityEngine;

namespace Core.Settings
{
    [DefaultExecutionOrder(-150)]
    public sealed class SettingsService : MonoBehaviour
    {
        public static SettingsService Instance { get; private set; }

        private const string KeyMusic = "settings.music_on";
        private const string KeySfx   = "settings.sfx_on";
        private const int    DefaultOn = 1;

        private bool _musicOn = true;
        private bool _sfxOn   = true;

        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
        private static void Bootstrap()
        {
            // забезпечуємо існування сервісу до завантаження будь-якої сцени
            if (Instance != null) return;
            var go = new GameObject("[SettingsService]");
            DontDestroyOnLoad(go);
            Instance = go.AddComponent<SettingsService>();
        }

        private void Awake()
        {
            if (Instance != null && Instance != this) { Destroy(gameObject); return; }
            Instance = this;
            DontDestroyOnLoad(gameObject);
            Load();
            // одразу розсилаємо стан, щоб інші підтягнулись
            EventBus.Invoke(new SettingsLoaded(_musicOn, _sfxOn));
            EventBus.Invoke(new SettingsChanged(_musicOn, _sfxOn));
        }

        private void OnEnable()
        {
            EventBus.Subscribe<MusicToggleRequested>(OnMusicToggleRequested);
            EventBus.Subscribe<SfxToggleRequested>(OnSfxToggleRequested);
            EventBus.Subscribe<SettingsSyncRequested>(OnSyncRequested);
        }

        private void OnDisable()
        {
            EventBus.Unsubscribe<MusicToggleRequested>(OnMusicToggleRequested);
            EventBus.Unsubscribe<SfxToggleRequested>(OnSfxToggleRequested);
            EventBus.Unsubscribe<SettingsSyncRequested>(OnSyncRequested);
        }

        private void OnMusicToggleRequested(MusicToggleRequested e)
        {
            if (_musicOn == e.IsOn) return;
            _musicOn = e.IsOn;
            Save();
            EventBus.Invoke(new SettingsChanged(_musicOn, _sfxOn));
        }

        private void OnSfxToggleRequested(SfxToggleRequested e)
        {
            if (_sfxOn == e.IsOn) return;
            _sfxOn = e.IsOn;
            Save();
            EventBus.Invoke(new SettingsChanged(_musicOn, _sfxOn));
        }

        private void OnSyncRequested(SettingsSyncRequested _)
        {
            EventBus.Invoke(new SettingsChanged(_musicOn, _sfxOn));
        }

        private void Load()
        {
            _musicOn = PlayerPrefs.GetInt(KeyMusic, DefaultOn) != 0;
            _sfxOn   = PlayerPrefs.GetInt(KeySfx,   DefaultOn) != 0;
        }

        private void Save()
        {
            PlayerPrefs.SetInt(KeyMusic, _musicOn ? 1 : 0);
            PlayerPrefs.SetInt(KeySfx,   _sfxOn   ? 1 : 0);
            PlayerPrefs.Save();
        }
    }
}


========== FILE: MainMenuController.cs ==========
using Core.EventBusSystem;
using UnityEngine;
using UnityEngine.SceneManagement;    // ✨ додали
using Core.SceneManagement;
using Menu.UI.Popups;

namespace Menu.UI
{
    public sealed class MainMenuController : MonoBehaviour
    {
        [Header("Popups")]
        [SerializeField] private MainMenuPopup mainMenuPopup;
        [SerializeField] private SettingsPopup settingsPopup;
        [SerializeField] private LevelSelectionPopup levelSelectionPopup;

        [Header("Config")]
        [SerializeField, Tooltip("Штучна доводка 75→100% при переході в гру")]
        private float startGameFakeFinish = 1.5f;

        private enum Panel { None, Main, Settings, Levels }
        private Panel _current = Panel.None;
        private bool _transitioning;

        private void Start()
        {
            // ✨ нове: якщо сцену меню запустили напряму з редактора (без LoadingScreen),
            // подія SceneReady не прийде — відкриваємо головне меню локально.
            if (SceneManager.GetActiveScene().name == SceneFlow.Menu)
                ShowMain();
        }

        private void OnEnable()
        {
            // Відкриття екранів
            EventBus.Subscribe<MenuEvents.OpenMainMenu>(OnOpenMain);
            EventBus.Subscribe<MenuEvents.OpenSettings>(OnOpenSettings);
            EventBus.Subscribe<MenuEvents.OpenLevelSelection>(OnOpenLevels);
            EventBus.Subscribe<MenuEvents.BackRequested>(OnBack);

            // Дії
            EventBus.Subscribe<MenuEvents.QuitRequested>(OnQuit);
            EventBus.Subscribe<MenuEvents.StartGameRequested>(OnStartGame);
            EventBus.Subscribe<MenuEvents.LevelChosen>(OnLevelChosen);

            // Коли меню-сцена готова (через LoadingScreen) — показати головне меню
            EventBus.Subscribe<SceneReady>(OnSceneReady);
        }

        private void OnDisable()
        {
            EventBus.Unsubscribe<MenuEvents.OpenMainMenu>(OnOpenMain);
            EventBus.Unsubscribe<MenuEvents.OpenSettings>(OnOpenSettings);
            EventBus.Unsubscribe<MenuEvents.OpenLevelSelection>(OnOpenLevels);
            EventBus.Unsubscribe<MenuEvents.BackRequested>(OnBack);

            EventBus.Unsubscribe<MenuEvents.QuitRequested>(OnQuit);
            EventBus.Unsubscribe<MenuEvents.StartGameRequested>(OnStartGame);
            EventBus.Unsubscribe<MenuEvents.LevelChosen>(OnLevelChosen);

            EventBus.Unsubscribe<SceneReady>(OnSceneReady);
        }

        // ---------- Event handlers ----------
        private void OnSceneReady(SceneReady e)
        {
            if (e.Name == SceneFlow.Menu)
                ShowMain();
        }

        private void OnOpenMain(MenuEvents.OpenMainMenu _)=> ShowMain();
        private void OnOpenSettings(MenuEvents.OpenSettings _)=> ShowSettings();
        private void OnOpenLevels(MenuEvents.OpenLevelSelection _)=> ShowLevels();
        private void OnBack(MenuEvents.BackRequested _)=> ShowMain();

        private void OnQuit(MenuEvents.QuitRequested _)
        {
            Application.Quit();
#if UNITY_EDITOR
            UnityEditor.EditorApplication.isPlaying = false;
#endif
        }

        private void OnStartGame(MenuEvents.StartGameRequested _)
        {
            SceneFlow.GoToGame(startGameFakeFinish);
        }

        private void OnLevelChosen(MenuEvents.LevelChosen e)
        {
            // TODO: зберегти e.LevelId у своєму GameData/Session, якщо потрібно
            SceneFlow.GoToGame(startGameFakeFinish);
        }

        // ---------- UI switching ----------
        private void HideAll()
        {
            if (mainMenuPopup) mainMenuPopup.HideView();
            if (settingsPopup) settingsPopup.HideView();
            if (levelSelectionPopup) levelSelectionPopup.HideView();
        }

        private void ShowMain()
        {
            if (_transitioning || _current == Panel.Main) return;
            _transitioning = true;
            HideAll();
            mainMenuPopup?.ShowView();
            _current = Panel.Main;
            _transitioning = false;
        }

        private void ShowSettings()
        {
            if (_transitioning || _current == Panel.Settings) return;
            _transitioning = true;
            HideAll();
            settingsPopup?.ShowView();
            _current = Panel.Settings;
            _transitioning = false;
        }

        private void ShowLevels()
        {
            if (_transitioning || _current == Panel.Levels) return;
            _transitioning = true;
            HideAll();
            levelSelectionPopup?.ShowView();
            _current = Panel.Levels;
            _transitioning = false;
        }
    }

    // Події меню тримаєш у окремому файлі MenuEvents.cs (як у тебе зараз).
}


========== FILE: MenuEvents.cs ==========
namespace Menu.UI
{
    public class MenuEvents
    {
        public readonly struct OpenMainMenu { }
        public readonly struct OpenSettings { }
        public readonly struct OpenLevelSelection { }
        public readonly struct BackRequested { }
        public readonly struct QuitRequested { }
        public readonly struct StartGameRequested { }
        public readonly struct LevelChosen
        {
            public readonly string LevelId;
            public LevelChosen(string levelId) => LevelId = levelId;
        }
    }
}

========== FILE: LevelsConfig.cs ==========
using System;

namespace Core.GamePlay.Levels
{
    [Serializable]
    public class LevelData
    {
        // Які символи спавнити по порядку (індекси в масиві symbolPrefabs)
        public int[] symbolPrefabIndices;

        // Параметри складності для цього рівня
        public float moveSpeed = 5f;
        public float stopDuration = 0.5f;
        public float hitWindow = 0.3f;
    }

    [Serializable]
    public class LevelsFile
    {
        public LevelData[] levels;
    }
}

========== FILE: SymbolNode.cs ==========
// SymbolNode.cs

using UnityEngine;

namespace Core.GamePlay.Symboll
{
    public class SymbolNode : MonoBehaviour
    {
        public SpriteRenderer sprite;
        public Color idleColor = Color.white;
        public Color activeColor = Color.yellow;

        bool _activated;

        void Reset()
        {
            sprite = GetComponentInChildren<SpriteRenderer>();
        }

        void Start()
        {
            SetIdle();
        }

        public void SetIdle()
        {
            _activated = false;
            if (sprite != null)
                sprite.color = idleColor;
        }

        public void Activate()
        {
            _activated = true;
            if (sprite != null)
                sprite.color = activeColor;
        }

        public bool IsActivated => _activated;
    }
}

========== FILE: BasePopup.cs ==========
using DG.Tweening;
using UnityEngine;

namespace Menu.UI.Popups
{
    public class BasePopup : MonoBehaviour
    {
        [SerializeField] protected Transform content;
        [SerializeField] protected CanvasGroup canvasGroup;
        [SerializeField] private float animationDuration = 0.5f;

        private Tween _fadeTween;

        // ВАЖЛИВО: НІЯКОГО Initial() В AWAKE!
        // Стан початкової видимості задаєш у префабі/сцені.
        protected virtual void Awake()
        {
            Debug.Log($"[Popup] Awake {name} (content.activeSelf={content?.gameObject.activeSelf}, alpha={canvasGroup?.alpha})", this);

            if (!canvasGroup)
                Debug.LogWarning($"[Popup] {name} CanvasGroup НЕ заданий", this);
            if (!content)
                Debug.LogWarning($"[Popup] {name} Content НЕ заданий", this);
        }

        protected virtual void OnDisable()
        {
            if (_fadeTween != null && _fadeTween.IsActive())
                _fadeTween.Kill();
        }

        public virtual void ShowView()
        {
            Debug.Log($"[Popup] ShowView {name}", this);

            if (_fadeTween != null && _fadeTween.IsActive())
                _fadeTween.Kill();

            if (content) content.gameObject.SetActive(true);

            if (canvasGroup)
            {
                canvasGroup.interactable = true;
                canvasGroup.blocksRaycasts = true;

                // миттєво піднімаємо alpha до 1, або хочеш — залиш tween
                _fadeTween = canvasGroup.DOFade(1f, animationDuration)
                    .SetEase(Ease.OutQuad)
                    .SetUpdate(true)
                    .OnComplete(() => canvasGroup.alpha = 1f);
            }
        }

        public virtual void HideView()
        {
            Debug.Log($"[Popup] HideView {name}", this);

            if (_fadeTween != null && _fadeTween.IsActive())
                _fadeTween.Kill();

            if (canvasGroup)
            {
                _fadeTween = canvasGroup.DOFade(0f, animationDuration)
                    .SetEase(Ease.InQuad)
                    .SetUpdate(true)
                    .OnComplete(() =>
                    {
                        if (content) content.gameObject.SetActive(false);
                        canvasGroup.interactable = false;
                        canvasGroup.blocksRaycasts = false;
                    });
            }
            else
            {
                if (content) content.gameObject.SetActive(false);
            }
        }
    }
}


========== FILE: LevelSelectionPopup.cs ==========
using System;
using Core.EventBusSystem;
using UnityEngine;
using UnityEngine.UI;
// LevelChosen, BackRequested

namespace Menu.UI.Popups
{
    public sealed class LevelSelectionPopup : BasePopup
    {
        [Serializable]
        private struct LevelEntry
        {
            public Button button;   // кнопка рівня
            public string levelId;  // або sceneName (як тобі зручніше)
        }

        [Header("Buttons")]
        [SerializeField] private LevelEntry[] levels;
        [SerializeField] private Button backButton;

        protected override void Awake()
        {
            base.Awake();

            if (levels != null)
            {
                for (int i = 0; i < levels.Length; i++)
                {
                    var entry = levels[i]; // копія для коректного замикання
                    if (entry.button)
                        entry.button.onClick.AddListener(() => OnLevelClicked(entry.levelId));
                }
            }

            if (backButton) backButton.onClick.AddListener(OnBackClicked);
        }

        private void OnDestroy()
        {
            if (levels != null)
            {
                for (int i = 0; i < levels.Length; i++)
                {
                    var entry = levels[i];
                    if (entry.button)
                        entry.button.onClick.RemoveAllListeners(); // або зберігати делегати і знімати точково
                }
            }

            if (backButton) backButton.onClick.RemoveListener(OnBackClicked);
        }

        private void OnLevelClicked(string levelId)
        {
            EventBus.Invoke(new MenuEvents.LevelChosen(levelId));
            // або, якщо стартуєш без збереження id:
            // EventBus.Invoke(new StartGameRequested());
        }

        private void OnBackClicked() => EventBus.Invoke(new MenuEvents.BackRequested());
    }
}

========== FILE: MainMenuPopup.cs ==========
using Core.EventBusSystem;
using UnityEngine;
using UnityEngine.UI;
// OpenSettings, OpenLevelSelection, QuitRequested, StartGameRequested (якщо треба)

namespace Menu.UI.Popups
{
    public sealed class MainMenuPopup : BasePopup
    {
        [Header("Buttons")]
        [SerializeField] private Button settingsButton;
        [SerializeField] private Button levelSelectButton;


        [SerializeField] private Button quitButton;

        protected override void Awake()
        {
            base.Awake();

            if (settingsButton)     settingsButton.onClick.AddListener(OnSettingsClicked);
            if (levelSelectButton)  levelSelectButton.onClick.AddListener(OnLevelSelectClicked);
            if (quitButton)         quitButton.onClick.AddListener(OnQuitClicked);
        }

        private void OnDestroy()
        {
            if (settingsButton)     settingsButton.onClick.RemoveListener(OnSettingsClicked);
            if (levelSelectButton)  levelSelectButton.onClick.RemoveListener(OnLevelSelectClicked);
            if (quitButton)         quitButton.onClick.RemoveListener(OnQuitClicked);
        }

        private void OnSettingsClicked()    => EventBus.Invoke(new MenuEvents.OpenSettings());
        private void OnLevelSelectClicked() => EventBus.Invoke(new MenuEvents.OpenLevelSelection());
        private void OnQuitClicked()        => EventBus.Invoke(new MenuEvents.QuitRequested());
    }
}

========== FILE: SettingsPopup.cs ==========
// Assets/Scripts/Menu/UI/Popups/SettingsPopup.cs
using Core.EventBusSystem;
using Core.Settings;
using UnityEngine;
using UnityEngine.UI;

namespace Menu.UI.Popups
{
    public sealed class SettingsPopup : BasePopup
    {
        [Header("Buttons")]
        [SerializeField] private Button backButton;

        [Header("Toggles")]
        [SerializeField] private Toggle musicToggle;
        [SerializeField] private Toggle sfxToggle;

        private bool _lockUi; 

        protected override void Awake()
        {
            base.Awake();

            if (backButton) backButton.onClick.AddListener(OnBackClicked);

            if (musicToggle) musicToggle.onValueChanged.AddListener(OnMusicToggle);
            if (sfxToggle)   sfxToggle.onValueChanged.AddListener(OnSfxToggle);
        }

        private void OnEnable()
        {
            EventBus.Subscribe<SettingsLoaded>(OnSettings);
            EventBus.Subscribe<SettingsChanged>(OnSettings);
            
            EventBus.Invoke(new SettingsSyncRequested());
        }

        protected override void OnDisable()
        {
            EventBus.Unsubscribe<SettingsLoaded>(OnSettings);
            EventBus.Unsubscribe<SettingsChanged>(OnSettings);
        }

        private void OnDestroy()
        {
            if (backButton)  backButton.onClick.RemoveListener(OnBackClicked);
            if (musicToggle) musicToggle.onValueChanged.RemoveListener(OnMusicToggle);
            if (sfxToggle)   sfxToggle.onValueChanged.RemoveListener(OnSfxToggle);
        }

        private void OnBackClicked() => EventBus.Invoke(new Menu.UI.MenuEvents.BackRequested());

        private void OnMusicToggle(bool isOn)
        {
            if (_lockUi) return;
            EventBus.Invoke(new MusicToggleRequested(isOn));
        }

        private void OnSfxToggle(bool isOn)
        {
            if (_lockUi) return;
            EventBus.Invoke(new SfxToggleRequested(isOn));
        }

        private void OnSettings(SettingsLoaded e)  => SyncUI(e.MusicOn, e.SfxOn);
        private void OnSettings(SettingsChanged e) => SyncUI(e.MusicOn, e.SfxOn);

        private void SyncUI(bool musicOn, bool sfxOn)
        {
            _lockUi = true;
            if (musicToggle) musicToggle.SetIsOnWithoutNotify(musicOn);
            if (sfxToggle)   sfxToggle.SetIsOnWithoutNotify(sfxOn);
            _lockUi = false;
        }
    }
}


