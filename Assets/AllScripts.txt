========== FILE: AudioService.cs ==========
// Assets/Scripts/Core/Audio/AudioService.cs
using Core.EventBusSystem;
using Core.Settings;
using Core.SceneManagement;
using UnityEngine;
using UnityEngine.Audio;

namespace Core.Audio
{
    [DefaultExecutionOrder(-120)]
    public sealed class AudioService : MonoBehaviour
    {
        public static AudioService Instance { get; private set; }

        [Header("Mixer")]
        [SerializeField] private AudioMixer masterMixer;
        [SerializeField] private string musicParam = "MusicVolume";
        [SerializeField] private string sfxParam   = "SFXVolume";

        [Header("Volumes (dB)")]
        [SerializeField] private float onDb  = 0f;
        [SerializeField] private float offDb = -80f;

        // ‚ùå –ø–æ–≤–Ω—ñ—Å—Ç—é –≤–∏–¥–∞–ª–µ–Ω–æ RuntimeInitializeOnLoadMethod + —Å–∞–º–æ—Å—Ç–≤–æ—Ä–µ–Ω–Ω—è!

        private void Awake()
        {
            if (Instance != null && Instance != this) { Destroy(gameObject); return; }
            Instance = this;
            DontDestroyOnLoad(gameObject);

            // fallback: —è–∫—â–æ –º—ñ–∫—Å–µ—Ä –Ω–µ –ø—ñ–¥–≤‚Äô—è–∑–∞–Ω–∏–π —É –ø—Ä–µ—Ñ–∞–±—ñ ‚Äî —Å–ø—Ä–æ–±—É—î–º–æ –¥—ñ—Å—Ç–∞—Ç–∏ –∑ Resources
            if (!masterMixer)
                masterMixer = Resources.Load<AudioMixer>("Audio/MasterMixer");

            if (!masterMixer)
                Debug.LogError("[AudioService] No AudioMixer assigned/found. Assign in prefab or put at Resources/Audio/MasterMixer.mixer");
        }

        private void OnEnable()
        {
            EventBus.Subscribe<SettingsLoaded>(OnSettingsLoaded);
            EventBus.Subscribe<SettingsChanged>(OnSettingsChanged);
            EventBus.Subscribe<SceneReady>(OnSceneReady);

            // –æ–¥—Ä–∞–∑—É —Å–∏–Ω—Ö—Ä–æ–Ω—ñ–∑—É—î–º–æ —Å—Ç–∞–Ω (—Ä–∞–ø—Ç–æ–º –ø—Ä–æ–ø—É—Å—Ç–∏–ª–∏ —Ä–∞–Ω–Ω—ñ –ø–æ–¥—ñ—ó)
            EventBus.Invoke(new SettingsSyncRequested());
        }

        private void OnDisable()
        {
            EventBus.Unsubscribe<SettingsLoaded>(OnSettingsLoaded);
            EventBus.Unsubscribe<SettingsChanged>(OnSettingsChanged);
            EventBus.Unsubscribe<SceneReady>(OnSceneReady);
        }

        private void OnSettingsLoaded(SettingsLoaded e)  => Apply(e.MusicOn, e.SfxOn);
        private void OnSettingsChanged(SettingsChanged e) => Apply(e.MusicOn, e.SfxOn);

        private void OnSceneReady(SceneReady _)
        {
            EventBus.Invoke(new SettingsSyncRequested());
        }

        private void Apply(bool musicOn, bool sfxOn)
        {
            if (!masterMixer)
            {
                Debug.LogWarning("[AudioService] No AudioMixer assigned.");
                return;
            }
            masterMixer.SetFloat(musicParam, musicOn ? onDb : offDb);
            masterMixer.SetFloat(sfxParam,   sfxOn   ? onDb : offDb);
        }
    }
}


========== FILE: EventBus.cs ==========
using System;
using System.Collections.Generic;

namespace Core.EventBusSystem
{
    public static class EventBus
    {
        private static readonly Dictionary<Type, List<Delegate>> _subscribers = new();

        public static void Subscribe<T>(Action<T> callback)
        {
            var type = typeof(T);
            if (!_subscribers.ContainsKey(type))
                _subscribers[type] = new List<Delegate>();

            _subscribers[type].Add(callback);
        }

        public static void Unsubscribe<T>(Action<T> callback)
        {
            var type = typeof(T);
            if (_subscribers.TryGetValue(type, out var list))
            {
                list.Remove(callback);
                if (list.Count == 0)
                    _subscribers.Remove(type);
            }
        }

        public static void Invoke<T>(T eventData)
        {
            var type = typeof(T);
            if (_subscribers.TryGetValue(type, out var list))
            {
                var snapshot = list.ToArray(); 
                for (int i = 0; i < snapshot.Length; i++)
                    (snapshot[i] as Action<T>)?.Invoke(eventData);
            }
        }

    }
}

========== FILE: IState.cs ==========
namespace Core.FSM
{
    public interface IState
    {
        void Enter();
        void Exit();
        void Update();
    }
}


========== FILE: StateMachine.cs ==========
namespace Core.FSM
{
    public sealed class StateMachine
    {
        private IState _current;
        public IState Current => _current;

        public void Change(IState next)
        {
            if (_current == next) return;
            _current?.Exit();
            _current = next;
            _current?.Enter();
        }

        public void Update() => _current?.Update();
    }
}

========== FILE: GameEvents.cs ==========
namespace Core.GamePlay
{
    public static class GameEvents
    {
        public readonly struct PauseRequested { }
        public readonly struct ResumeRequested { }

        public readonly struct RestartRequested { }
        public readonly struct NextLevelRequested { }
        public readonly struct GoToMenuRequested { }

        public readonly struct LevelCompleted { }
        public readonly struct LevelFailed { }
    }
}

========== FILE: GameManager.cs ==========
using System.Collections.Generic;
using Core.EventBusSystem;
using Core.GamePlay.Levels;
using Core.GamePlay.Symboll;
using Core.GamePlay.UI;
using Core.SceneManagement;
using UnityEngine;

namespace Core.GamePlay
{
    /// <summary>
    /// –õ–æ–≥—ñ–∫–∞ —Ä—ñ–≤–Ω—è:
    /// 1) –°–ø–∞–≤–Ω–∏—Ç—å —Å–∏–º–≤–æ–ª–∏ –∑–≥—ñ–¥–Ω–æ –∑ JSON.
    /// 2) –ì–µ–Ω–µ—Ä—É—î –ø–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—å (–∑–∞—Ä–∞–∑: —É—Å—ñ —Å–∏–º–≤–æ–ª–∏ –ø–æ –ø–æ—Ä—è–¥–∫—É).
    /// 3) –§–ê–ó–ê –ü–û–ö–ê–ó–£: –ø—Ä–æ–º—ñ–Ω—å –ª—ñ—Ç–∞—î –ø–æ –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ—Å—Ç—ñ, —Å–∏–º–≤–æ–ª–∏ –ø—ñ–¥—Å–≤—ñ—á—É—é—Ç—å—Å—è.
    /// 4) –§–ê–ó–ê –í–í–û–î–£: –≥—Ä–∞–≤–µ—Ü—å –∫–ª—ñ–∫–∞—î –ø–æ —Å–∏–º–≤–æ–ª–∞—Ö —É —Ç–æ–º—É –∂ –ø–æ—Ä—è–¥–∫—É.
    ///    - —è–∫—â–æ –∫–ª—ñ–∫ –ø—Ä–∞–≤–∏–ª—å–Ω–∏–π -> —Ä—É—Ö–∞—î–º–æ—Å—å –¥–∞–ª—ñ;
    ///    - —è–∫—â–æ –ø–æ–º–∏–ª–∫–æ–≤–∏–π -> LevelFailed();
    ///    - —è–∫—â–æ –≤—Å—è –ø–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—å –ø—Ä–æ–π–¥–µ–Ω–∞ -> LevelComplete().
    /// </summary>
    public class GameManager : MonoBehaviour
    {
        [Header("Refs")]
        public SunBeamController beam;

        [Tooltip("–ü–æ–∑–∏—Ü—ñ—ó, –¥–µ –º–æ–∂—É—Ç—å —Å–ø–∞–≤–Ω–∏—Ç–∏—Å—å —Å–∏–º–≤–æ–ª–∏ (–ø–æ –ø–æ—Ä—è–¥–∫—É).")]
        public Transform[] spawnPoints;

        [Tooltip("–í—Å—ñ –≤–∏–¥–∏ —Å–∏–º–≤–æ–ª—ñ–≤ (–ø—Ä–µ—Ñ–∞–±–∏).")]
        public SymbolNode[] symbolPrefabs;

        [Header("Levels config file (JSON)")]
        public TextAsset levelsJson;   // —Å—é–¥–∏ –ø—ñ–¥–∫–∏–¥–∞—î–º–æ –∑–≥–µ–Ω–µ—Ä–æ–≤–∞–Ω–∏–π levels.json

        LevelsFile _levelsFile;
        LevelData _currentLevel;

        [Header("Debug / Manual")]
        [Tooltip("–Ø–∫–∏–π —ñ–Ω–¥–µ–∫—Å —Ä—ñ–≤–Ω—è –±—Ä–∞—Ç–∏ –∑ JSON (0-based) –ø—Ä–∏ –∑–∞–ø—É—Å–∫—É —Å—Ü–µ–Ω–∏ –Ω–∞–ø—Ä—è–º—É.")]
        public int currentLevelIndex = 0;

        [Header("UI")]
        [SerializeField] private GameplayHud gameplayHud;

        readonly List<SymbolNode> _spawnedSymbols = new List<SymbolNode>();

        // –ø–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—å, —è–∫—É –ø–æ–∫–∞–∑—É—î–º–æ —ñ —è–∫—É –≥—Ä–∞–≤–µ—Ü—å –º–∞—î –ø–æ–≤—Ç–æ—Ä–∏—Ç–∏
        int[] _sequence;
        int _inputIndex = 0;

        bool _isShowingSequence = false;
        bool _isInputPhase = false;
        bool _levelFinished = false;
        bool _isPaused = false;

        int _lastHighlightedIndex = -1;

        private void OnEnable()
        {
            EventBus.Subscribe<GameEvents.RestartRequested>(OnRestartRequested);
            EventBus.Subscribe<GameEvents.NextLevelRequested>(OnNextLevelRequested);
            EventBus.Subscribe<GameEvents.GoToMenuRequested>(OnGoToMenuRequested);
            EventBus.Subscribe<GameEvents.PauseRequested>(OnPauseRequested);
            EventBus.Subscribe<GameEvents.ResumeRequested>(OnResumeRequested);
        }

        private void OnDisable()
        {
            EventBus.Unsubscribe<GameEvents.RestartRequested>(OnRestartRequested);
            EventBus.Unsubscribe<GameEvents.NextLevelRequested>(OnNextLevelRequested);
            EventBus.Unsubscribe<GameEvents.GoToMenuRequested>(OnGoToMenuRequested);
            EventBus.Unsubscribe<GameEvents.PauseRequested>(OnPauseRequested);
            EventBus.Unsubscribe<GameEvents.ResumeRequested>(OnResumeRequested);
        }

        void Start()
        {
            if (!beam)
            {
                Debug.LogError("GameManager: beam not set!");
                enabled = false;
                return;
            }

            if (!levelsJson)
            {
                Debug.LogError("GameManager: levelsJson (TextAsset) is not assigned!");
                enabled = false;
                return;
            }

            // —Ä–æ–∑–ø–∞—Ä—Å–∏—Ç–∏ JSON
            _levelsFile = JsonUtility.FromJson<LevelsFile>(levelsJson.text);
            if (_levelsFile == null || _levelsFile.levels == null || _levelsFile.levels.Length == 0)
            {
                Debug.LogError("GameManager: no levels in JSON!");
                enabled = false;
                return;
            }

            // üîπ –±–µ—Ä–µ–º–æ —ñ–Ω–¥–µ–∫—Å —Ä—ñ–≤–Ω—è —ñ–∑ GameSession
            int savedIndex = GameSession.CurrentLevelIndex;

            if (savedIndex < 0 || savedIndex >= _levelsFile.levels.Length)
                savedIndex = 0;

            currentLevelIndex = savedIndex;
            _currentLevel = _levelsFile.levels[currentLevelIndex];

            // üîπ –≤ UI –ø–æ–∫–∞–∑—É—î–º–æ human-friendly –Ω–æ–º–µ—Ä (1,2,3...)
            if (gameplayHud != null)
                gameplayHud.SetLevel(currentLevelIndex + 1);

            SetupLevel();
            StartShowSequence();
        }

        void SetupLevel()
        {
            foreach (var s in _spawnedSymbols)
            {
                if (s != null)
                    Destroy(s.gameObject);
            }

            _spawnedSymbols.Clear();

            if (_currentLevel.symbolPrefabIndices == null || _currentLevel.symbolPrefabIndices.Length == 0)
            {
                Debug.LogError("Current level has no symbolPrefabIndices!");
                return;
            }

            bool hasSpawnMap = _currentLevel.spawnPointIndices != null &&
                               _currentLevel.spawnPointIndices.Length > 0;

            if (!hasSpawnMap)
            {
                Debug.LogWarning($"Level {currentLevelIndex}: no spawnPointIndices in JSON, using default [0..N-1].");
            }

            int count = Mathf.Min(_currentLevel.symbolPrefabIndices.Length, spawnPoints.Length);

            for (int i = 0; i < count; i++)
            {
                int prefabIndex = _currentLevel.symbolPrefabIndices[i];

                if (prefabIndex < 0 || prefabIndex >= symbolPrefabs.Length)
                {
                    Debug.LogError($"Invalid prefab index {prefabIndex} in level {currentLevelIndex}");
                    continue;
                }

                int spawnIndex;
                if (hasSpawnMap)
                {
                    if (i >= _currentLevel.spawnPointIndices.Length)
                    {
                        Debug.LogWarning(
                            $"Level {currentLevelIndex}: spawnPointIndices shorter than symbolPrefabIndices. Using index=i fallback.");
                        spawnIndex = i;
                    }
                    else
                    {
                        spawnIndex = _currentLevel.spawnPointIndices[i];
                    }
                }
                else
                {
                    spawnIndex = i;
                }

                if (spawnIndex < 0 || spawnIndex >= spawnPoints.Length)
                {
                    Debug.LogError(
                        $"Level {currentLevelIndex}: invalid spawnPoint index {spawnIndex}. Skipping symbol {i}.");
                    continue;
                }

                SymbolNode prefab = symbolPrefabs[prefabIndex];
                Transform point = spawnPoints[spawnIndex];

                SymbolNode instance = Instantiate(prefab, point.position, Quaternion.identity);
                instance.SetIdle();
                instance.SetHighlighted(false);

                _spawnedSymbols.Add(instance);
            }

            _lastHighlightedIndex = -1;
            _levelFinished = false;
            _isShowingSequence = false;
            _isInputPhase = false;
            _isPaused = false;
            Time.timeScale = 1f;

            // üëá –ü–û–†–Ø–î–û–ö –ü–Ü–î–ö–ê–ó–ö–ò –ë–ï–†–ï–ú–û –ó JSON
            BuildSequence();
        }
        void BuildSequence()
        {
            // –Ñ sequenceIndices –≤ JSON?
            if (_currentLevel.sequenceIndices != null && _currentLevel.sequenceIndices.Length > 0)
            {
                List<int> valid = new List<int>();
                for (int i = 0; i < _currentLevel.sequenceIndices.Length; i++)
                {
                    int idx = _currentLevel.sequenceIndices[i];
                    if (idx < 0 || idx >= _spawnedSymbols.Count)
                    {
                        Debug.LogWarning(
                            $"Level {currentLevelIndex}: sequence index {idx} out of range (0..{_spawnedSymbols.Count - 1}), skipping.");
                        continue;
                    }
                    valid.Add(idx);
                }

                if (valid.Count > 0)
                {
                    _sequence = valid.ToArray();
                    return;
                }

                Debug.LogWarning($"Level {currentLevelIndex}: sequenceIndices invalid/empty after filtering, using default 0..N-1.");
            }

            // fallback: –ø—Ä–æ—Å—Ç–æ 0..N-1
            _sequence = new int[_spawnedSymbols.Count];
            for (int i = 0; i < _sequence.Length; i++)
                _sequence[i] = i;
        }




        /// <summary>
        /// –ó–∞–ø—É—Å–∫–∞—î–º–æ –§–ê–ó–£ –ü–û–ö–ê–ó–£: –ø—Ä–æ–º—ñ–Ω—å —Ö–æ–¥–∏—Ç—å –ø–æ —Å–∏–º–≤–æ–ª–∞—Ö —É –ø–æ—Ä—è–¥–∫—É _sequence.
        /// </summary>
        void StartShowSequence()
        {
            if (_sequence == null || _sequence.Length == 0)
            {
                Debug.LogError("GameManager: sequence is empty, nothing to show.");
                return;
            }

            _isShowingSequence = true;
            _isInputPhase = false;
            _inputIndex = 0;
            _lastHighlightedIndex = -1;

            Transform[] seqPoints = new Transform[_sequence.Length];
            for (int i = 0; i < _sequence.Length; i++)
            {
                int idx = _sequence[i];
                seqPoints[i] = _spawnedSymbols[idx].transform;
            }

            // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ moveSpeed / stopDuration –∑ LevelData —è–∫ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –ø–æ–∫–∞–∑—É
            beam.PlaySequence(
                seqPoints,
                _currentLevel.moveSpeed,
                _currentLevel.stopDuration,
                OnShowStep,
                OnShowFinished
            );
        }

        /// <summary>
        /// –í–∏–∫–ª–∏–∫–∞—î—Ç—å—Å—è SunBeamController –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ –∫—Ä–æ–∫—É –ø–æ–∫–∞–∑—É.
        /// –∫—Ä–æ–∫ i –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—î _sequence[i].
        /// </summary>
        void OnShowStep(int stepIndex)
        {
            int symbolIndex = _sequence[stepIndex];

            // –≥–∞—Å–∏–º–æ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ–π highlight
            if (_lastHighlightedIndex >= 0 && _lastHighlightedIndex < _spawnedSymbols.Count)
                _spawnedSymbols[_lastHighlightedIndex].SetHighlighted(false);

            // –ø—ñ–¥—Å–≤—ñ—á—É—î–º–æ –ø–æ—Ç–æ—á–Ω–∏–π
            if (symbolIndex >= 0 && symbolIndex < _spawnedSymbols.Count)
            {
                _spawnedSymbols[symbolIndex].SetHighlighted(true);
                _lastHighlightedIndex = symbolIndex;
            }
        }

        /// <summary>
        /// –í–∏–∫–ª–∏–∫–∞—î—Ç—å—Å—è, –∫–æ–ª–∏ –ø–æ–∫–∞–∑ —É—Å—ñ—î—ó –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ—Å—Ç—ñ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–π.
        /// </summary>
        void OnShowFinished()
        {
            // –≥–∞—Å–∏–º–æ –æ—Å—Ç–∞–Ω–Ω—ñ–π highlight
            if (_lastHighlightedIndex >= 0 && _lastHighlightedIndex < _spawnedSymbols.Count)
                _spawnedSymbols[_lastHighlightedIndex].SetHighlighted(false);

            _lastHighlightedIndex = -1;

            _isShowingSequence = false;
            _isInputPhase = true;
            _inputIndex = 0;

            Debug.Log("GameManager: sequence show finished. Waiting for player input...");
        }

        void Update()
        {
            if (_levelFinished || _isPaused)
                return;

            if (!_isInputPhase)
                return;

            bool pressed = false;
            Vector3 screenPos = Vector3.zero;

#if UNITY_ANDROID || UNITY_IOS
            if (Input.touchCount > 0 && Input.GetTouch(0).phase == TouchPhase.Began)
            {
                pressed = true;
                screenPos = Input.GetTouch(0).position;
            }
            if (Input.GetMouseButtonDown(0))
            {
                pressed = true;
                screenPos = Input.mousePosition;
            }
#else 
            if (Input.GetMouseButtonDown(0))
            {
                pressed = true;
                screenPos = Input.mousePosition;
            }
#endif

            if (pressed)
            {
                HandleInputClick(screenPos);
            }
        }

        void HandleInputClick(Vector3 screenPos)
        {
            if (Camera.main == null)
            {
                Debug.LogError("GameManager: no main camera for raycast.");
                return;
            }

            Vector3 worldPos = Camera.main.ScreenToWorldPoint(screenPos);
            Vector2 pos2D = new Vector2(worldPos.x, worldPos.y);

            var hit = Physics2D.Raycast(pos2D, Vector2.zero);
            if (!hit.collider)
                return;

            var node = hit.collider.GetComponent<SymbolNode>();
            if (!node)
                return;

            int clickedIndex = _spawnedSymbols.IndexOf(node);
            if (clickedIndex < 0)
                return;

            OnSymbolClicked(clickedIndex);
        }

        void OnSymbolClicked(int clickedIndex)
        {
            if (!_isInputPhase || _levelFinished || _isPaused)
                return;

            if (_inputIndex < 0 || _inputIndex >= _sequence.Length)
                return;

            int expectedIndex = _sequence[_inputIndex];

            if (clickedIndex == expectedIndex)
            {
                // –ø—Ä–∞–≤–∏–ª—å–Ω–∏–π –∫–ª—ñ–∫
                _spawnedSymbols[clickedIndex].Activate();
                Debug.Log($"Correct click {clickedIndex} (step {_inputIndex + 1}/{_sequence.Length})");

                _inputIndex++;

                if (_inputIndex >= _sequence.Length)
                {
                    LevelComplete();
                }
            }
            else
            {
                Debug.Log($"Wrong click! expected={expectedIndex}, got={clickedIndex}");
                LevelFailed();
            }
        }

        void LevelComplete()
        {
            _levelFinished = true;
            _isInputPhase = false;

            Debug.Log($"LEVEL COMPLETE! Level index = {currentLevelIndex}");

            // üîπ –ó–ë–ï–†–Ü–ì–ê–Ñ–ú–û –ü–†–û–ì–†–ï–°: —Ä–æ–∑–±–ª–æ–∫—É–≤–∞—Ç–∏ –Ω–∞—Å—Ç—É–ø–Ω–∏–π —Ä—ñ–≤–µ–Ω—å, —è–∫—â–æ –≤—ñ–Ω —ñ—Å–Ω—É—î
            int nextIndex = currentLevelIndex + 1;
            if (_levelsFile != null && _levelsFile.levels != null && nextIndex < _levelsFile.levels.Length)
            {
                // –∑–±–µ—Ä–µ–∂–µ–º–æ "–Ω–∞–π–≤–∏—â–∏–π –¥–æ—Å—è–≥–Ω—É—Ç–∏–π" —Ä—ñ–≤–µ–Ω—å,
                // –∞–ª–µ –Ω–µ –∑–º–µ–Ω—à—É—î–º–æ, —è–∫—â–æ –≤–∂–µ –¥—ñ–π—à–ª–∏ –¥–∞–ª—ñ —Ä–∞–Ω—ñ—à–µ
                if (nextIndex > GameSession.CurrentLevelIndex)
                    GameSession.CurrentLevelIndex = nextIndex;
            }

            EventBus.Invoke(new GameEvents.LevelCompleted());
        }

        void LevelFailed()
        {
            _levelFinished = true;
            _isInputPhase = false;

            Debug.Log($"LEVEL FAILED! Level index = {currentLevelIndex}");
            EventBus.Invoke(new GameEvents.LevelFailed());
        }

        // ---------- HANDLERS UI PODIY ----------

        void OnPauseRequested(GameEvents.PauseRequested _)
        {
            if (_levelFinished || _isPaused) return;
            _isPaused = true;
            Time.timeScale = 0f;
        }

        void OnResumeRequested(GameEvents.ResumeRequested _)
        {
            if (!_isPaused) return;
            _isPaused = false;
            Time.timeScale = 1f;
        }

        void OnRestartRequested(GameEvents.RestartRequested _)
        {
            _isPaused = false;
            Time.timeScale = 1f;

            // –¥–æ—Å—Ç–∞—Ç–Ω—å–æ —Å–∫–∏–Ω—É—Ç–∏ —Ä—ñ–≤–µ–Ω—å —Ç–∞ –∑–∞–Ω–æ–≤–æ –ø–æ–∫–∞–∑–∞—Ç–∏ –ø–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—å
            SetupLevel();
            StartShowSequence();
        }

        void OnNextLevelRequested(GameEvents.NextLevelRequested _)
        {
            _isPaused = false;
            Time.timeScale = 1f;

            int nextIndex = currentLevelIndex + 1;
            if (_levelsFile != null && _levelsFile.levels != null && nextIndex < _levelsFile.levels.Length)
            {
                currentLevelIndex = nextIndex;
                _currentLevel = _levelsFile.levels[currentLevelIndex];

                if (gameplayHud != null)
                    gameplayHud.SetLevel(currentLevelIndex + 1);

                SetupLevel();
                StartShowSequence();
            }
            else
            {
                // —è–∫—â–æ –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ —Ä—ñ–≤–Ω—è –Ω–µ–º–∞ ‚Äî –∫–∏–¥–∞—î–º–æ –≤ –º–µ–Ω—é
                SceneFlow.GoToMenu(0.2f);
            }
        }

        void OnGoToMenuRequested(GameEvents.GoToMenuRequested _)
        {
            _isPaused = false;
            Time.timeScale = 1f;
            SceneFlow.GoToMenu(0.2f);
        }
    }
}


========== FILE: GameSession.cs ==========
using UnityEngine;

namespace Core.GamePlay
{
    public static class GameSession
    {
        private const string LevelIndexKey = "progress.level_index";

        /// <summary>
        /// –ü–æ—Ç–æ—á–Ω–∏–π (–æ—Å—Ç–∞–Ω–Ω—ñ–π –¥–æ—Å—è–≥–Ω—É—Ç–∏–π / —Ä–æ–∑–±–ª–æ–∫–æ–≤–∞–Ω–∏–π) —Ä—ñ–≤–µ–Ω—å, 0-based.
        /// –ó–±–µ—Ä—ñ–≥–∞—î—Ç—å—Å—è –≤ PlayerPrefs.
        /// </summary>
        public static int CurrentLevelIndex
        {
            get => PlayerPrefs.GetInt(LevelIndexKey, 0);
            set
            {
                if (value < 0) value = 0;
                PlayerPrefs.SetInt(LevelIndexKey, value);
                PlayerPrefs.Save();
            }
        }

        /// <summary>
        /// –Ø–∫—â–æ —Ö–æ—á–µ—à —â–µ –∑–±–µ—Ä—ñ–≥–∞—Ç–∏ string-id (–∞–ª–µ –ø–æ–∫–∏ —â–æ –Ω–µ —á—ñ–ø–∞—î–º–æ).
        /// </summary>
        public static string CurrentLevelId { get; set; } = "0";
    }
}

========== FILE: SunBeamController.cs ==========
using System;
using System.Collections;
using UnityEngine;

namespace Core.GamePlay
{
    public class SunBeamController : MonoBehaviour
    {
        [Header("Beam Origin (—Å—Ç–∞—Ä—Ç–æ–≤–∞ —Ç–æ—á–∫–∞)")]
        [SerializeField] private Transform beamOrigin;

        [Header("Beam Prefab (movingPoint + TrailRenderer)")]
        [SerializeField] private GameObject beamPrefab;

        [Header("Settings")]
        [SerializeField] private float reachDistance = 0.05f;

        private GameObject _currentBeam;

        private Coroutine _routine;

        public void PlaySequence(
            Transform[] points,
            float moveSpeed,
            float stopDuration,
            Action<int> onStep,
            Action onFinished)
        {
            if (_routine != null)
                StopCoroutine(_routine);

            _routine = StartCoroutine(ShowRoutine(points, moveSpeed, stopDuration, onStep, onFinished));
        }

        private IEnumerator ShowRoutine(
            Transform[] points,
            float moveSpeed,
            float stopDuration,
            Action<int> onStep,
            Action onFinished)
        {
            for (int i = 0; i < points.Length; i++)
            {
                Vector3 target = points[i].position;

                // –°—Ç–≤–æ—Ä—é—î–º–æ –Ω–æ–≤–∏–π –ø—Ä–æ–º—ñ–Ω—å
                SpawnBeam();

                // –õ–µ—Ç–∏–º–æ
                yield return MoveBeamTo(target, moveSpeed);

                // –ø–æ–≤—ñ–¥–æ–º–ª—è—î–º–æ GameManager –ø—Ä–æ –∫—Ä–æ–∫
                onStep?.Invoke(i);

                // —á–µ–∫–∞—î–º–æ, –ø–æ–∫–∏ —Å–∏–º–≤–æ–ª –ø—ñ–¥—Å–≤—ñ—á–µ–Ω–∏–π
                yield return new WaitForSeconds(stopDuration);

                // –í–∏–¥–∞–ª—è—î–º–æ –ø—Ä–æ–º—ñ–Ω—å
                ClearBeam();
            }

            ClearBeam();

            onFinished?.Invoke();
        }

        /// <summary>
        /// –°—Ç–≤–æ—Ä–µ–Ω–Ω—è –Ω–æ–≤–æ–≥–æ –ø—Ä–æ–º–µ–Ω—è
        /// </summary>
        private void SpawnBeam()
        {
            // –í–∏–¥–∞–ª—è—î–º–æ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ–π, —è–∫—â–æ –≤—ñ–Ω –±—É–≤
            ClearBeam();

            _currentBeam = Instantiate(beamPrefab, beamOrigin.position, Quaternion.identity);
        }

        /// <summary>
        /// –†—É—Ö beamPrefab ‚Üí target
        /// </summary>
        private IEnumerator MoveBeamTo(Vector3 target, float speed)
        {
            Transform mover = _currentBeam.transform;

            // —Å–∫–∏–¥–∞—î–º–æ —Ç—Ä–µ–π–ª, —è–∫—â–æ —î
            var trail = mover.GetComponent<TrailRenderer>();
            if (trail) trail.Clear();

            while (Vector3.Distance(mover.position, target) > reachDistance)
            {
                mover.position = Vector3.MoveTowards(
                    mover.position,
                    target,
                    speed * Time.deltaTime
                );

                yield return null;
            }

            mover.position = target;
        }

        /// <summary>
        /// –í–∏–¥–∞–ª—è—î –ø–æ—Ç–æ—á–Ω–∏–π –ø—Ä–æ–º—ñ–Ω—å
        /// </summary>
        private void ClearBeam()
        {
            if (_currentBeam != null)
            {
                Destroy(_currentBeam);
                _currentBeam = null;
            }
        }
    }
}


========== FILE: Bootstrap.cs ==========
// Assets/Scripts/Core/SceneManagement/Bootstrap.cs
using UnityEngine;
using Core.Audio; // ‚Üê –¥–æ–¥–∞–π

namespace Core.SceneManagement
{
    public static class Bootstrap
    {
        private const string LoadingScreenResPath = "UI/LoadingScreen";
        private const string AudioServiceResPath  = "Systems/AudioService"; // ‚Üê –Ω–æ–≤–µ

        private const string MainMenuScene = "MainMenuScene";
        private const float  FirstShowDelay = 2.0f;

        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
        private static void Init()
        {
            if (LoadingScreen.Instance == null)
            {
                var prefab = Resources.Load<LoadingScreen>(LoadingScreenResPath);
                if (prefab != null) Object.Instantiate(prefab);
                else Debug.LogError("[Bootstrap] Missing Resources/UI/LoadingScreen.prefab with LoadingScreen component.");
            }
            
            if (AudioService.Instance == null)
            {
                var audioPrefab = Resources.Load<AudioService>(AudioServiceResPath);
                if (audioPrefab != null) Object.Instantiate(audioPrefab);
                else Debug.LogError("[Bootstrap] Missing Resources/Systems/AudioService.prefab with AudioService component.");
            }

            LoadingScreen.Instance?.LoadScene(MainMenuScene, FirstShowDelay);
        }
    }
}

========== FILE: LoadingScreen.cs ==========
using System.Collections;
using Core.EventBusSystem;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.UI;
// ‚ú® –¥–æ–¥–∞–ª–∏
using Core.SceneManagement;    // ‚ú® –¥–æ–¥–∞–ª–∏ (–¥–ª—è SceneLoadingStarted/Loaded/Ready)

namespace Core.SceneManagement
{
    [DefaultExecutionOrder(-100)]
    public sealed class LoadingScreen : MonoBehaviour
    {
        public static LoadingScreen Instance { get; private set; }

        [Header("UI")]
        [SerializeField] private GameObject root;     // –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –µ–∫—Ä–∞–Ω–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è
        [SerializeField] private Slider progressBar;  // —ñ–Ω–¥–∏–∫–∞—Ç–æ—Ä –ø—Ä–æ–≥—Ä–µ—Å—É (0..1)

        [Header("Config (Inspector)")]
        [SerializeField, Tooltip("–®–≤–∏–¥–∫—ñ—Å—Ç—å –∑–≥–ª–∞–¥–∂—É–≤–∞–Ω–Ω—è –∑–∞–ø–æ–≤–Ω–µ–Ω–Ω—è (–≤—ñ–∑—É–∞–ª—å–Ω–æ).")]
        private float smoothSpeed = 6f;
        
        private const float DefaultFakeFinishTime = 1.0f;

        private Coroutine _routine;
        private bool _isLoading;
        private string _targetScene;

        private void Awake()
        {
            if (Instance != null && Instance != this) { Destroy(gameObject); return; }
            Instance = this;
            DontDestroyOnLoad(gameObject);

            if (root) root.SetActive(false);
            if (progressBar) progressBar.value = 0f;
        }
        
        public void LoadScene(string sceneName, float? fakeDelayOverride = null)
        {
            if (string.IsNullOrWhiteSpace(sceneName))
            {
                Debug.LogError("[LoadingScreen] Scene name is null or empty.");
                return;
            }
            
            if (SceneManager.GetActiveScene().name == sceneName)
            {
                Debug.LogWarning($"[LoadingScreen] Scene '{sceneName}' is already active.");
                root?.SetActive(false);
                return;
            }
            
            if (!Application.CanStreamedLevelBeLoaded(sceneName))
            {
                Debug.LogError($"[LoadingScreen] Scene '{sceneName}' is not in Build Settings.");
                return;
            }
            
            if (_isLoading && _targetScene == sceneName)
                return;

            if (_routine != null) StopCoroutine(_routine);

            _isLoading = true;
            _targetScene = sceneName;

            root?.SetActive(true);
            if (progressBar) progressBar.value = 0f;

            float fakeDelay = fakeDelayOverride ?? DefaultFakeFinishTime;
            _routine = StartCoroutine(LoadSceneRoutine(sceneName, fakeDelay));
        }

        private IEnumerator LoadSceneRoutine(string sceneName, float fakeDelay)
        {
            // –¥–∞—Ç–∏ Canvas –≤—ñ–¥–º–∞–ª—é–≤–∞—Ç–∏—Å—è –ø–µ—Ä–µ–¥ —Å—Ç–∞—Ä—Ç–æ–º –≤–∞–∂–∫–æ–≥–æ –ª–æ–∞–¥—É
            Canvas.ForceUpdateCanvases();
            yield return null;

            // ‚ú® –Ω–æ–≤–µ: –∫–∏–Ω—É–ª–∏ –ø–æ–¥—ñ—é "–ø–æ—á–∞–ª–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Å—Ü–µ–Ω–∏"
            EventBus.Invoke(new SceneLoadingStarted(sceneName));

            var async = SceneManager.LoadSceneAsync(sceneName);
            async.allowSceneActivation = false;

            float shown = 0f;
            const float realPhaseMax = 0.75f; // –¥–æ 75% ‚Äî —Ä–µ–∞–ª—å–Ω–∏–π –ø—Ä–æ–≥—Ä–µ—Å
            const float unityCap     = 0.9f;  // Unity –∑–≤—ñ—Ç—É—î 0.9 –¥–æ –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó

            // --- –§–ê–ó–ê 1: —Ä–µ–∞–ª—å–Ω–∏–π –ø—Ä–æ–≥—Ä–µ—Å (0‚Äì75%) ---
            while (async.progress < unityCap)
            {
                float normalized = Mathf.Clamp01(async.progress / unityCap); // 0..1
                float target = normalized * realPhaseMax;                    // 0..0.75
                shown = Mathf.MoveTowards(shown, target, Time.unscaledDeltaTime * smoothSpeed);

                if (progressBar) progressBar.value = shown;
                yield return null;
            }

            // --- –§–ê–ó–ê 2: —à—Ç—É—á–Ω–∞ –∑–∞—Ç—Ä–∏–º–∫–∞ 75‚Äì100% ---
            float timer = 0f;
            while (timer < fakeDelay)
            {
                timer += Time.unscaledDeltaTime;
                float t = Mathf.Clamp01(timer / fakeDelay);
                float target = Mathf.Lerp(realPhaseMax, 1f, t); // 0.75 ‚Üí 1.0 –∑–∞ fakeDelay
                shown = Mathf.MoveTowards(shown, target, Time.unscaledDeltaTime * smoothSpeed);

                if (progressBar) progressBar.value = shown;
                yield return null;
            }

            // –≥–∞—Ä–∞–Ω—Ç—É–≤–∞—Ç–∏ 100% —ñ –¥–∞—Ç–∏ –æ–¥–∏–Ω –∫–∞–¥—Ä –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è
            if (progressBar) progressBar.value = 1f;
            yield return null;

            // --- –ê–∫—Ç–∏–≤—É—î–º–æ —Å—Ü–µ–Ω—É ---
            async.allowSceneActivation = true;
            while (!async.isDone) yield return null;

            // ‚ú® –Ω–æ–≤–µ: –ø–æ–≤—ñ–¥–æ–º–∏–ª–∏, —â–æ —Å—Ü–µ–Ω–∞ –∞–∫—Ç–∏–≤–æ–≤–∞–Ω–∞
            EventBus.Invoke(new SceneLoaded(sceneName));
            // ‚ú® –Ω–æ–≤–µ: —â–µ –æ–¥–∏–Ω –∫–∞–¥—Ä ‚Äî –¥–∞—î–º–æ Awake/Start —É –Ω–æ–≤—ñ–π —Å—Ü–µ–Ω—ñ –≤—ñ–¥–ø—Ä–∞—Ü—é–≤–∞—Ç–∏
            yield return null;
            // ‚ú® –Ω–æ–≤–µ: —Ç–µ–ø–µ—Ä —Å—Ü–µ–Ω–∞ –≥–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–æ "–≥–æ—Ç–æ–≤–∞" –¥–ª—è UI/–∫–æ–Ω—Ç—Ä–æ–ª–µ—Ä—ñ–≤
            EventBus.Invoke(new SceneReady(sceneName));

            // –∫–æ—Ä–æ—Ç–∫–∏–π –±—É—Ñ–µ—Ä, —â–æ–± —É–Ω–∏–∫–Ω—É—Ç–∏ "–±–ª–∏–º–∞–Ω–Ω—è" –Ω–∞ –¥—É–∂–µ —à–≤–∏–¥–∫–∏—Ö —Å—Ü–µ–Ω–∞—Ö
            yield return new WaitForSecondsRealtime(0.2f);

            if (root) root.SetActive(false);
            _isLoading = false;
            _targetScene = null;
            _routine = null;
        }
    }
}


========== FILE: SceneEvents.cs ==========
namespace Core.SceneManagement
{
    public readonly struct SceneLoadingStarted { public readonly string Target; public SceneLoadingStarted(string t)=>Target=t; }
    public readonly struct SceneLoaded        { public readonly string Name;   public SceneLoaded(string n)=>Name=n; }
    public readonly struct SceneReady         { public readonly string Name;   public SceneReady(string n)=>Name=n; }
}

========== FILE: SceneFlow.cs ==========
namespace Core.SceneManagement
{
    public static class SceneFlow
    {
        public const string Menu = "MainMenuScene";
        public const string Game = "GameScene";

        public static void GoToMenu(float? fake = null) => LoadingScreen.Instance?.LoadScene(Menu, fake);
        public static void GoToGame(float? fake = null) => LoadingScreen.Instance?.LoadScene(Game, fake);
    }
}

========== FILE: SettingsEvents.cs ==========
namespace Core.Settings
{
    public readonly struct SettingsLoaded
    {
        public readonly bool MusicOn;
        public readonly bool SfxOn;
        public SettingsLoaded(bool musicOn, bool sfxOn) { MusicOn = musicOn; SfxOn = sfxOn; }
    }
    
    public readonly struct SettingsChanged
    {
        public readonly bool MusicOn;
        public readonly bool SfxOn;
        public SettingsChanged(bool musicOn, bool sfxOn) { MusicOn = musicOn; SfxOn = sfxOn; }
    }
    
    public readonly struct MusicToggleRequested { public readonly bool IsOn; public MusicToggleRequested(bool isOn) { IsOn = isOn; } }
    public readonly struct SfxToggleRequested   { public readonly bool IsOn; public SfxToggleRequested(bool isOn)   { IsOn = isOn; } }
    
    public readonly struct SettingsSyncRequested { }
}

========== FILE: SettingsService.cs ==========
// Assets/Scripts/Core/Settings/SettingsService.cs
using Core.EventBusSystem;
using UnityEngine;

namespace Core.Settings
{
    [DefaultExecutionOrder(-150)]
    public sealed class SettingsService : MonoBehaviour
    {
        public static SettingsService Instance { get; private set; }

        private const string KeyMusic = "settings.music_on";
        private const string KeySfx   = "settings.sfx_on";
        private const int    DefaultOn = 1;

        private bool _musicOn = true;
        private bool _sfxOn   = true;

        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
        private static void Bootstrap()
        {
            // –∑–∞–±–µ–∑–ø–µ—á—É—î–º–æ —ñ—Å–Ω—É–≤–∞–Ω–Ω—è —Å–µ—Ä–≤—ñ—Å—É –¥–æ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –±—É–¥—å-—è–∫–æ—ó —Å—Ü–µ–Ω–∏
            if (Instance != null) return;
            var go = new GameObject("[SettingsService]");
            DontDestroyOnLoad(go);
            Instance = go.AddComponent<SettingsService>();
        }

        private void Awake()
        {
            if (Instance != null && Instance != this) { Destroy(gameObject); return; }
            Instance = this;
            DontDestroyOnLoad(gameObject);
            Load();
            // –æ–¥—Ä–∞–∑—É —Ä–æ–∑—Å–∏–ª–∞—î–º–æ —Å—Ç–∞–Ω, —â–æ–± —ñ–Ω—à—ñ –ø—ñ–¥—Ç—è–≥–Ω—É–ª–∏—Å—å
            EventBus.Invoke(new SettingsLoaded(_musicOn, _sfxOn));
            EventBus.Invoke(new SettingsChanged(_musicOn, _sfxOn));
        }

        private void OnEnable()
        {
            EventBus.Subscribe<MusicToggleRequested>(OnMusicToggleRequested);
            EventBus.Subscribe<SfxToggleRequested>(OnSfxToggleRequested);
            EventBus.Subscribe<SettingsSyncRequested>(OnSyncRequested);
        }

        private void OnDisable()
        {
            EventBus.Unsubscribe<MusicToggleRequested>(OnMusicToggleRequested);
            EventBus.Unsubscribe<SfxToggleRequested>(OnSfxToggleRequested);
            EventBus.Unsubscribe<SettingsSyncRequested>(OnSyncRequested);
        }

        private void OnMusicToggleRequested(MusicToggleRequested e)
        {
            if (_musicOn == e.IsOn) return;
            _musicOn = e.IsOn;
            Save();
            EventBus.Invoke(new SettingsChanged(_musicOn, _sfxOn));
        }

        private void OnSfxToggleRequested(SfxToggleRequested e)
        {
            if (_sfxOn == e.IsOn) return;
            _sfxOn = e.IsOn;
            Save();
            EventBus.Invoke(new SettingsChanged(_musicOn, _sfxOn));
        }

        private void OnSyncRequested(SettingsSyncRequested _)
        {
            EventBus.Invoke(new SettingsChanged(_musicOn, _sfxOn));
        }

        private void Load()
        {
            _musicOn = PlayerPrefs.GetInt(KeyMusic, DefaultOn) != 0;
            _sfxOn   = PlayerPrefs.GetInt(KeySfx,   DefaultOn) != 0;
        }

        private void Save()
        {
            PlayerPrefs.SetInt(KeyMusic, _musicOn ? 1 : 0);
            PlayerPrefs.SetInt(KeySfx,   _sfxOn   ? 1 : 0);
            PlayerPrefs.Save();
        }
    }
}


========== FILE: MainMenuController.cs ==========
using Core.EventBusSystem;
using UnityEngine;
using UnityEngine.SceneManagement;    // ‚ú® –¥–æ–¥–∞–ª–∏
using Core.SceneManagement;
using Menu.UI.Popups;

namespace Menu.UI
{
    public sealed class MainMenuController : MonoBehaviour
    {
        [Header("Popups")]
        [SerializeField] private MainMenuPopup mainMenuPopup;
        [SerializeField] private SettingsPopup settingsPopup;
        [SerializeField] private LevelSelectionPopup levelSelectionPopup;

        [Header("Config")]
        [SerializeField, Tooltip("–®—Ç—É—á–Ω–∞ –¥–æ–≤–æ–¥–∫–∞ 75‚Üí100% –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥—ñ –≤ –≥—Ä—É")]
        private float startGameFakeFinish = 1.5f;

        private enum Panel { None, Main, Settings, Levels }
        private Panel _current = Panel.None;
        private bool _transitioning;

        private void Start()
        {
            // ‚ú® –Ω–æ–≤–µ: —è–∫—â–æ —Å—Ü–µ–Ω—É –º–µ–Ω—é –∑–∞–ø—É—Å—Ç–∏–ª–∏ –Ω–∞–ø—Ä—è–º—É –∑ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞ (–±–µ–∑ LoadingScreen),
            // –ø–æ–¥—ñ—è SceneReady –Ω–µ –ø—Ä–∏–π–¥–µ ‚Äî –≤—ñ–¥–∫—Ä–∏–≤–∞—î–º–æ –≥–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é –ª–æ–∫–∞–ª—å–Ω–æ.
            if (SceneManager.GetActiveScene().name == SceneFlow.Menu)
                ShowMain();
        }

        private void OnEnable()
        {
            // –í—ñ–¥–∫—Ä–∏—Ç—Ç—è –µ–∫—Ä–∞–Ω—ñ–≤
            EventBus.Subscribe<MenuEvents.OpenMainMenu>(OnOpenMain);
            EventBus.Subscribe<MenuEvents.OpenSettings>(OnOpenSettings);
            EventBus.Subscribe<MenuEvents.OpenLevelSelection>(OnOpenLevels);
            EventBus.Subscribe<MenuEvents.BackRequested>(OnBack);

            // –î—ñ—ó
            EventBus.Subscribe<MenuEvents.QuitRequested>(OnQuit);
            EventBus.Subscribe<MenuEvents.StartGameRequested>(OnStartGame);
            EventBus.Subscribe<MenuEvents.LevelChosen>(OnLevelChosen);

            // –ö–æ–ª–∏ –º–µ–Ω—é-—Å—Ü–µ–Ω–∞ –≥–æ—Ç–æ–≤–∞ (—á–µ—Ä–µ–∑ LoadingScreen) ‚Äî –ø–æ–∫–∞–∑–∞—Ç–∏ –≥–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é
            EventBus.Subscribe<SceneReady>(OnSceneReady);
        }

        private void OnDisable()
        {
            EventBus.Unsubscribe<MenuEvents.OpenMainMenu>(OnOpenMain);
            EventBus.Unsubscribe<MenuEvents.OpenSettings>(OnOpenSettings);
            EventBus.Unsubscribe<MenuEvents.OpenLevelSelection>(OnOpenLevels);
            EventBus.Unsubscribe<MenuEvents.BackRequested>(OnBack);

            EventBus.Unsubscribe<MenuEvents.QuitRequested>(OnQuit);
            EventBus.Unsubscribe<MenuEvents.StartGameRequested>(OnStartGame);
            EventBus.Unsubscribe<MenuEvents.LevelChosen>(OnLevelChosen);

            EventBus.Unsubscribe<SceneReady>(OnSceneReady);
        }

        // ---------- Event handlers ----------
        private void OnSceneReady(SceneReady e)
        {
            if (e.Name == SceneFlow.Menu)
                ShowMain();
        }

        private void OnOpenMain(MenuEvents.OpenMainMenu _)=> ShowMain();
        private void OnOpenSettings(MenuEvents.OpenSettings _)=> ShowSettings();
        private void OnOpenLevels(MenuEvents.OpenLevelSelection _)=> ShowLevels();
        private void OnBack(MenuEvents.BackRequested _)=> ShowMain();

        private void OnQuit(MenuEvents.QuitRequested _)
        {
            Application.Quit();
#if UNITY_EDITOR
            UnityEditor.EditorApplication.isPlaying = false;
#endif
        }

        private void OnStartGame(MenuEvents.StartGameRequested _)
        {
            SceneFlow.GoToGame(startGameFakeFinish);
        }

        private void OnLevelChosen(MenuEvents.LevelChosen e)
        {
            // TODO: –∑–±–µ—Ä–µ–≥—Ç–∏ e.LevelId —É —Å–≤–æ—î–º—É GameData/Session, —è–∫—â–æ –ø–æ—Ç—Ä—ñ–±–Ω–æ
            SceneFlow.GoToGame(startGameFakeFinish);
        }

        // ---------- UI switching ----------
        private void HideAll()
        {
            if (mainMenuPopup) mainMenuPopup.HideView();
            if (settingsPopup) settingsPopup.HideView();
            if (levelSelectionPopup) levelSelectionPopup.HideView();
        }

        private void ShowMain()
        {
            if (_transitioning || _current == Panel.Main) return;
            _transitioning = true;
            HideAll();
            mainMenuPopup?.ShowView();
            _current = Panel.Main;
            _transitioning = false;
        }

        private void ShowSettings()
        {
            if (_transitioning || _current == Panel.Settings) return;
            _transitioning = true;
            HideAll();
            settingsPopup?.ShowView();
            _current = Panel.Settings;
            _transitioning = false;
        }

        private void ShowLevels()
        {
            if (_transitioning || _current == Panel.Levels) return;
            _transitioning = true;
            HideAll();
            levelSelectionPopup?.ShowView();
            _current = Panel.Levels;
            _transitioning = false;
        }
    }

    // –ü–æ–¥—ñ—ó –º–µ–Ω—é —Ç—Ä–∏–º–∞—î—à —É –æ–∫—Ä–µ–º–æ–º—É —Ñ–∞–π–ª—ñ MenuEvents.cs (—è–∫ —É —Ç–µ–±–µ –∑–∞—Ä–∞–∑).
}


========== FILE: MenuEvents.cs ==========
namespace Menu.UI
{
    public class MenuEvents
    {
        public readonly struct OpenMainMenu { }
        public readonly struct OpenSettings { }
        public readonly struct OpenLevelSelection { }
        public readonly struct BackRequested { }
        public readonly struct QuitRequested { }
        public readonly struct StartGameRequested { }
        public readonly struct LevelChosen
        {
            public readonly string LevelId;
            public LevelChosen(string levelId) => LevelId = levelId;
        }
    }
}

========== FILE: LevelsConfig.cs ==========
// LevelsConfig.cs
using System;

namespace Core.GamePlay.Levels
{
    [Serializable]
    public class LevelData
    {
        // –Ø–∫—ñ —Å–∏–º–≤–æ–ª–∏ —Å–ø–∞–≤–Ω–∏—Ç–∏ (—ñ–Ω–¥–µ–∫—Å–∏ –≤ –º–∞—Å–∏–≤—ñ symbolPrefabs)
        public int[] symbolPrefabIndices;

        // –í —è–∫–∏–π spawnPoint —Å—Ç–∞–≤–∏—Ç–∏ –∫–æ–∂–µ–Ω —Å–∏–º–≤–æ–ª (—ñ–Ω–¥–µ–∫—Å–∏ –≤ –º–∞—Å–∏–≤—ñ spawnPoints —É GameManager)
        public int[] spawnPointIndices;

        // üëá –ù–û–í–ï: —É —è–∫–æ–º—É –ø–æ—Ä—è–¥–∫—É –ø—Ä–æ–º—ñ–Ω—å –±—É–¥–µ —ó—Ö –ø–æ–∫–∞–∑—É–≤–∞—Ç–∏ / –≥—Ä–∞–≤–µ—Ü—å –º–∞—î –∫–ª—ñ–∫–∞—Ç–∏
        // –∑–Ω–∞—á–µ–Ω–Ω—è ‚Äì —ñ–Ω–¥–µ–∫—Å–∏ –≤ —Å–ø–∏—Å–∫—É _spawnedSymbols (0..N-1)
        public int[] sequenceIndices;

        // –ü–∞—Ä–∞–º–µ—Ç—Ä–∏ —Å–∫–ª–∞–¥–Ω–æ—Å—Ç—ñ –¥–ª—è —Ü—å–æ–≥–æ —Ä—ñ–≤–Ω—è
        public float moveSpeed = 5f;
        public float stopDuration = 0.5f;
        public float hitWindow = 0.3f;
    }

    [Serializable]
    public class LevelsFile
    {
        public LevelData[] levels;
    }
}

========== FILE: SymbolNode.cs ==========
using UnityEngine;

namespace Core.GamePlay.Symboll
{
    public class SymbolNode : MonoBehaviour
    {
        [Header("Visuals")]
        public SpriteRenderer sprite;
        public Color idleColor = Color.white;
        public Color activeColor = Color.yellow;

        [Header("Highlight Settings")]
        [SerializeField] private float highlightScaleMul = 1.1f;

        private bool _activated;
        private Vector3 _baseScale;

        void Reset()
        {
            sprite = GetComponentInChildren<SpriteRenderer>();
        }

        void Awake()
        {
            // –±–∞–∑–æ–≤–∏–π scale
            _baseScale = transform.localScale;

            // –ú–û–ñ–ù–ê —Ç—É—Ç —Å–∫–∏–Ω—É—Ç–∏ —Å—Ç–∞–Ω –æ–¥–∏–Ω —Ä–∞–∑ –ø—Ä–∏ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—ñ
            SetIdle();
            SetHighlighted(false);
        }

        // ‚ùå Start –ø—Ä–∏–±–∏—Ä–∞—î–º–æ –∑–æ–≤—Å—ñ–º, –∞–±–æ –∑–∞–ª–∏—à–∞—î–º–æ –ø—É—Å—Ç–∏–º
        // void Start() { }

        public void SetIdle()
        {
            _activated = false;
            if (sprite != null)
                sprite.color = idleColor;
        }

        public void Activate()
        {
            _activated = true;
            if (sprite != null)
                sprite.color = activeColor;
        }

        public bool IsActivated => _activated;

        public void SetHighlighted(bool highlighted)
        {
            transform.localScale = highlighted
                ? _baseScale * highlightScaleMul
                : _baseScale;
        }
    }
}

========== FILE: GameplayHud.cs ==========
// Assets/Scripts/Core/GamePlay/UI/GameplayHud.cs
using Core.EventBusSystem;
using UnityEngine;
using UnityEngine.UI;
using Menu.UI.Popups;
using TMPro; // BasePopup

namespace Core.GamePlay.UI
{
    public sealed class GameplayHud : BasePopup
    {
        [Header("Buttons")]
        [SerializeField] private Button pauseButton;

        [Header("Texts")]
        [SerializeField] private TextMeshProUGUI levelText; // –∞–±–æ TMP_Text, —è–∫—â–æ —Ö–æ—á–µ—à ‚Äî —Ç–æ–¥—ñ –ø–æ–º—ñ–Ω—è–π —Ç–∏–ø

        protected override void Awake()
        {
            base.Awake();

            if (pauseButton)
                pauseButton.onClick.AddListener(OnPauseClicked);
        }

        private void OnDestroy()
        {
            if (pauseButton)
                pauseButton.onClick.RemoveListener(OnPauseClicked);
        }

        private void OnPauseClicked()
        {
            EventBus.Invoke(new GameEvents.PauseRequested());
        }

        public void SetLevel(int levelNumber)
        {
            if (!levelText) return;
            levelText.text = $"Level {levelNumber}";
        }
    }
}

========== FILE: GameUIManager.cs ==========
using Core.EventBusSystem;
using UnityEngine;

namespace Core.GamePlay.UI
{
    public sealed class GameUIManager : MonoBehaviour
    {
        [Header("Views")]
        [SerializeField] private GameplayHud gameplayHud;
        [SerializeField] private PausePopup pausePopup;
        [SerializeField] private WinPopup winPopup;
        [SerializeField] private LosePopup losePopup;

        private void Awake()
        {
            if (pausePopup) pausePopup.HideView();
            if (winPopup)   winPopup.HideView();
            if (losePopup)  losePopup.HideView();
            if (gameplayHud) gameplayHud.ShowView();
        }

        private void OnEnable()
        {
            EventBus.Subscribe<GameEvents.PauseRequested>(OnPauseRequested);
            EventBus.Subscribe<GameEvents.ResumeRequested>(OnResumeRequested);
            EventBus.Subscribe<GameEvents.LevelCompleted>(OnLevelCompleted);
            EventBus.Subscribe<GameEvents.LevelFailed>(OnLevelFailed);
            EventBus.Subscribe<GameEvents.RestartRequested>(OnRestartRequested);
            EventBus.Subscribe<GameEvents.GoToMenuRequested>(OnGoToMenuRequested);   // üëà –¥–æ–¥–∞–Ω–æ
        }

        private void OnDisable()
        {
            EventBus.Unsubscribe<GameEvents.PauseRequested>(OnPauseRequested);
            EventBus.Unsubscribe<GameEvents.ResumeRequested>(OnResumeRequested);
            EventBus.Unsubscribe<GameEvents.LevelCompleted>(OnLevelCompleted);
            EventBus.Unsubscribe<GameEvents.LevelFailed>(OnLevelFailed);
            EventBus.Unsubscribe<GameEvents.RestartRequested>(OnRestartRequested);
            EventBus.Unsubscribe<GameEvents.GoToMenuRequested>(OnGoToMenuRequested); // üëà –¥–æ–¥–∞–Ω–æ
        }

        void OnPauseRequested(GameEvents.PauseRequested _)
        {
            if (pausePopup) pausePopup.ShowView();
        }

        void OnResumeRequested(GameEvents.ResumeRequested _)
        {
            if (pausePopup) pausePopup.HideView();
        }

        void OnLevelCompleted(GameEvents.LevelCompleted _)
        {
            if (pausePopup) pausePopup.HideView();
            if (winPopup)   winPopup.ShowView();
        }

        void OnLevelFailed(GameEvents.LevelFailed _)
        {
            if (pausePopup) pausePopup.HideView();
            if (losePopup)  losePopup.ShowView();
        }

        void OnRestartRequested(GameEvents.RestartRequested _)
        {
            if (pausePopup) pausePopup.HideView();
            if (winPopup)   winPopup.HideView();
            if (losePopup)  losePopup.HideView();
            if (gameplayHud) gameplayHud.ShowView();
        }

        // üëá –Ω–æ–≤–µ ‚Äî —Ö–æ–≤–∞—î PausePopup –ø—Ä–∏ –≤–∏—Ö–æ–¥—ñ –≤ –º–µ–Ω—é
        void OnGoToMenuRequested(GameEvents.GoToMenuRequested _)
        {
            if (pausePopup) pausePopup.HideView();
            if (winPopup)   winPopup.HideView();
            if (losePopup)  losePopup.HideView();
        }
    }
}


========== FILE: LosePopup.cs ==========
// Assets/Scripts/Core/GamePlay/UI/LosePopup.cs
using Core.EventBusSystem;
using UnityEngine;
using UnityEngine.UI;
using Menu.UI.Popups;

namespace Core.GamePlay.UI
{
    public sealed class LosePopup : BasePopup
    {
        [SerializeField] private Button restartButton;
        [SerializeField] private Button menuButton;

        protected override void Awake()
        {
            base.Awake();

            if (restartButton) restartButton.onClick.AddListener(OnRestartClicked);
            if (menuButton)    menuButton.onClick.AddListener(OnMenuClicked);
        }

        private void OnDestroy()
        {
            if (restartButton) restartButton.onClick.RemoveListener(OnRestartClicked);
            if (menuButton)    menuButton.onClick.RemoveListener(OnMenuClicked);
        }

        private void OnRestartClicked()
        {
            EventBus.Invoke(new GameEvents.RestartRequested());
        }

        private void OnMenuClicked()
        {
            EventBus.Invoke(new GameEvents.GoToMenuRequested());
        }
    }
}

========== FILE: PausePopup.cs ==========
// Assets/Scripts/Core/GamePlay/UI/PausePopup.cs
using Core.EventBusSystem;
using UnityEngine;
using UnityEngine.UI;
using Menu.UI.Popups;

namespace Core.GamePlay.UI
{
    public sealed class PausePopup : BasePopup
    {
        [Header("Buttons")]
        [SerializeField] private Button resumeButton;
        [SerializeField] private Button restartButton;
        [SerializeField] private Button menuButton;

        protected override void Awake()
        {
            base.Awake();

            if (resumeButton)  resumeButton.onClick.AddListener(OnResumeClicked);
            if (restartButton) restartButton.onClick.AddListener(OnRestartClicked);
            if (menuButton)    menuButton.onClick.AddListener(OnMenuClicked);
        }

        private void OnDestroy()
        {
            if (resumeButton)  resumeButton.onClick.RemoveListener(OnResumeClicked);
            if (restartButton) restartButton.onClick.RemoveListener(OnRestartClicked);
            if (menuButton)    menuButton.onClick.RemoveListener(OnMenuClicked);
        }

        private void OnResumeClicked()
        {
            EventBus.Invoke(new GameEvents.ResumeRequested());
        }

        private void OnRestartClicked()
        {
            EventBus.Invoke(new GameEvents.RestartRequested());
        }

        private void OnMenuClicked()
        {
            EventBus.Invoke(new GameEvents.GoToMenuRequested());
        }
    }
}

========== FILE: WinPopup.cs ==========
// Assets/Scripts/Core/GamePlay/UI/WinPopup.cs
using Core.EventBusSystem;
using UnityEngine;
using UnityEngine.UI;
using Menu.UI.Popups;

namespace Core.GamePlay.UI
{
    public sealed class WinPopup : BasePopup
    {
        [Header("Buttons")]
        [SerializeField] private Button nextLevelButton;
        [SerializeField] private Button menuButton;

        protected override void Awake()
        {
            base.Awake();

            if (nextLevelButton)
                nextLevelButton.onClick.AddListener(OnNextClicked);

            if (menuButton)
                menuButton.onClick.AddListener(OnMenuClicked);
        }

        private void OnDestroy()
        {
            if (nextLevelButton)
                nextLevelButton.onClick.RemoveListener(OnNextClicked);

            if (menuButton)
                menuButton.onClick.RemoveListener(OnMenuClicked);
        }

        private void OnNextClicked()
        {
            // ‚ú® —Ö–æ–≤–∞—î–º–æ –ø–æ–ø–∞–ø –ø–µ—Ä–µ–º–æ–≥–∏ –ø–µ—Ä–µ–¥ –ø–µ—Ä–µ—Ö–æ–¥–æ–º –Ω–∞ –Ω–∞—Å—Ç—É–ø–Ω–∏–π —Ä—ñ–≤–µ–Ω—å
            HideView();
            EventBus.Invoke(new GameEvents.NextLevelRequested());
        }

        private void OnMenuClicked()
        {
            // ‚ú® —Ö–æ–≤–∞—î–º–æ –ø–æ–ø–∞–ø –ø–µ—Ä–µ–º–æ–≥–∏ –ø–µ—Ä–µ–¥ –≤–∏—Ö–æ–¥–æ–º —É –º–µ–Ω—é
            HideView();
            EventBus.Invoke(new GameEvents.GoToMenuRequested());
        }
    }
}

========== FILE: BasePopup.cs ==========
using DG.Tweening;
using UnityEngine;

namespace Menu.UI.Popups
{
    public class BasePopup : MonoBehaviour
    {
        [SerializeField] protected Transform content;
        [SerializeField] protected CanvasGroup canvasGroup;
        [SerializeField] private float animationDuration = 0.5f;

        private Tween _fadeTween;

        // –í–ê–ñ–õ–ò–í–û: –ù–Ü–Ø–ö–û–ì–û Initial() –í AWAKE!
        // –°—Ç–∞–Ω –ø–æ—á–∞—Ç–∫–æ–≤–æ—ó –≤–∏–¥–∏–º–æ—Å—Ç—ñ –∑–∞–¥–∞—î—à —É –ø—Ä–µ—Ñ–∞–±—ñ/—Å—Ü–µ–Ω—ñ.
        protected virtual void Awake()
        {
            Debug.Log($"[Popup] Awake {name} (content.activeSelf={content?.gameObject.activeSelf}, alpha={canvasGroup?.alpha})", this);

            if (!canvasGroup)
                Debug.LogWarning($"[Popup] {name} CanvasGroup –ù–ï –∑–∞–¥–∞–Ω–∏–π", this);
            if (!content)
                Debug.LogWarning($"[Popup] {name} Content –ù–ï –∑–∞–¥–∞–Ω–∏–π", this);
        }

        protected virtual void OnDisable()
        {
            if (_fadeTween != null && _fadeTween.IsActive())
                _fadeTween.Kill();
        }

        public virtual void ShowView()
        {
            Debug.Log($"[Popup] ShowView {name}", this);

            if (_fadeTween != null && _fadeTween.IsActive())
                _fadeTween.Kill();

            if (content) content.gameObject.SetActive(true);

            if (canvasGroup)
            {
                canvasGroup.interactable = true;
                canvasGroup.blocksRaycasts = true;

                // –º–∏—Ç—Ç—î–≤–æ –ø—ñ–¥–Ω—ñ–º–∞—î–º–æ alpha –¥–æ 1, –∞–±–æ —Ö–æ—á–µ—à ‚Äî –∑–∞–ª–∏—à tween
                _fadeTween = canvasGroup.DOFade(1f, animationDuration)
                    .SetEase(Ease.OutQuad)
                    .SetUpdate(true)
                    .OnComplete(() => canvasGroup.alpha = 1f);
            }
        }

        public virtual void HideView()
        {
            Debug.Log($"[Popup] HideView {name}", this);

            if (_fadeTween != null && _fadeTween.IsActive())
                _fadeTween.Kill();

            if (canvasGroup)
            {
                _fadeTween = canvasGroup.DOFade(0f, animationDuration)
                    .SetEase(Ease.InQuad)
                    .SetUpdate(true)
                    .OnComplete(() =>
                    {
                        if (content) content.gameObject.SetActive(false);
                        canvasGroup.interactable = false;
                        canvasGroup.blocksRaycasts = false;
                    });
            }
            else
            {
                if (content) content.gameObject.SetActive(false);
            }
        }
    }
}


========== FILE: LevelSelectionPopup.cs ==========
using System;
using Core.EventBusSystem;
using UnityEngine;
using UnityEngine.UI;
// LevelChosen, BackRequested

namespace Menu.UI.Popups
{
    public sealed class LevelSelectionPopup : BasePopup
    {
        [Serializable]
        private struct LevelEntry
        {
            public Button button;   // –∫–Ω–æ–ø–∫–∞ —Ä—ñ–≤–Ω—è
            public string levelId;  // –∞–±–æ sceneName (—è–∫ —Ç–æ–±—ñ –∑—Ä—É—á–Ω—ñ—à–µ)
        }

        [Header("Buttons")]
        [SerializeField] private LevelEntry[] levels;
        [SerializeField] private Button backButton;

        protected override void Awake()
        {
            base.Awake();

            if (levels != null)
            {
                for (int i = 0; i < levels.Length; i++)
                {
                    var entry = levels[i]; // –∫–æ–ø—ñ—è –¥–ª—è –∫–æ—Ä–µ–∫—Ç–Ω–æ–≥–æ –∑–∞–º–∏–∫–∞–Ω–Ω—è
                    if (entry.button)
                        entry.button.onClick.AddListener(() => OnLevelClicked(entry.levelId));
                }
            }

            if (backButton) backButton.onClick.AddListener(OnBackClicked);
        }

        private void OnDestroy()
        {
            if (levels != null)
            {
                for (int i = 0; i < levels.Length; i++)
                {
                    var entry = levels[i];
                    if (entry.button)
                        entry.button.onClick.RemoveAllListeners(); // –∞–±–æ –∑–±–µ—Ä—ñ–≥–∞—Ç–∏ –¥–µ–ª–µ–≥–∞—Ç–∏ —ñ –∑–Ω—ñ–º–∞—Ç–∏ —Ç–æ—á–∫–æ–≤–æ
                }
            }

            if (backButton) backButton.onClick.RemoveListener(OnBackClicked);
        }

        private void OnLevelClicked(string levelId)
        {
            EventBus.Invoke(new MenuEvents.LevelChosen(levelId));
            // –∞–±–æ, —è–∫—â–æ —Å—Ç–∞—Ä—Ç—É—î—à –±–µ–∑ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è id:
            // EventBus.Invoke(new StartGameRequested());
        }

        private void OnBackClicked() => EventBus.Invoke(new MenuEvents.BackRequested());
    }
}

========== FILE: MainMenuPopup.cs ==========
using Core.EventBusSystem;
using UnityEngine;
using UnityEngine.UI;

namespace Menu.UI.Popups
{
    public sealed class MainMenuPopup : BasePopup
    {
        [Header("Buttons")]
        [SerializeField] private Button settingsButton;
        [SerializeField] private Button levelSelectButton;
        [SerializeField] private Button quitButton;

        protected override void Awake()
        {
            base.Awake();

            if (settingsButton)
                settingsButton.onClick.AddListener(OnSettingsClicked);

            if (levelSelectButton)
                levelSelectButton.onClick.AddListener(OnLevelSelectClicked);

            if (quitButton)
                quitButton.onClick.AddListener(OnQuitClicked);
        }

        private void OnDestroy()
        {
            if (settingsButton)
                settingsButton.onClick.RemoveListener(OnSettingsClicked);

            if (levelSelectButton)
                levelSelectButton.onClick.RemoveListener(OnLevelSelectClicked);

            if (quitButton)
                quitButton.onClick.RemoveListener(OnQuitClicked);
        }

        private void OnSettingsClicked()
            => EventBus.Invoke(new MenuEvents.OpenSettings());
        
        private void OnLevelSelectClicked()
            => EventBus.Invoke(new MenuEvents.StartGameRequested());

        private void OnQuitClicked()
            => EventBus.Invoke(new MenuEvents.QuitRequested());
    }
}

========== FILE: SettingsPopup.cs ==========
// Assets/Scripts/Menu/UI/Popups/SettingsPopup.cs
using Core.EventBusSystem;
using Core.Settings;
using UnityEngine;
using UnityEngine.UI;

namespace Menu.UI.Popups
{
    public sealed class SettingsPopup : BasePopup
    {
        [Header("Buttons")]
        [SerializeField] private Button backButton;

        [Header("Toggles")]
        [SerializeField] private Toggle musicToggle;
        [SerializeField] private Toggle sfxToggle;

        private bool _lockUi; 

        protected override void Awake()
        {
            base.Awake();

            if (backButton) backButton.onClick.AddListener(OnBackClicked);

            if (musicToggle) musicToggle.onValueChanged.AddListener(OnMusicToggle);
            if (sfxToggle)   sfxToggle.onValueChanged.AddListener(OnSfxToggle);
        }

        private void OnEnable()
        {
            EventBus.Subscribe<SettingsLoaded>(OnSettings);
            EventBus.Subscribe<SettingsChanged>(OnSettings);
            
            EventBus.Invoke(new SettingsSyncRequested());
        }

        protected override void OnDisable()
        {
            EventBus.Unsubscribe<SettingsLoaded>(OnSettings);
            EventBus.Unsubscribe<SettingsChanged>(OnSettings);
        }

        private void OnDestroy()
        {
            if (backButton)  backButton.onClick.RemoveListener(OnBackClicked);
            if (musicToggle) musicToggle.onValueChanged.RemoveListener(OnMusicToggle);
            if (sfxToggle)   sfxToggle.onValueChanged.RemoveListener(OnSfxToggle);
        }

        private void OnBackClicked() => EventBus.Invoke(new Menu.UI.MenuEvents.BackRequested());

        private void OnMusicToggle(bool isOn)
        {
            if (_lockUi) return;
            EventBus.Invoke(new MusicToggleRequested(isOn));
        }

        private void OnSfxToggle(bool isOn)
        {
            if (_lockUi) return;
            EventBus.Invoke(new SfxToggleRequested(isOn));
        }

        private void OnSettings(SettingsLoaded e)  => SyncUI(e.MusicOn, e.SfxOn);
        private void OnSettings(SettingsChanged e) => SyncUI(e.MusicOn, e.SfxOn);

        private void SyncUI(bool musicOn, bool sfxOn)
        {
            _lockUi = true;
            if (musicToggle) musicToggle.SetIsOnWithoutNotify(musicOn);
            if (sfxToggle)   sfxToggle.SetIsOnWithoutNotify(sfxOn);
            _lockUi = false;
        }
    }
}


